# 면접 대비 

## String, StringBuilder, StringBuffer

* String은 immutable, private final char[] 형태
* immutable인 이유 : 퍼포먼스, 동시성, GC
* StringBuilder, StringBuffer은 mutable
* StringBuffer는 Thread safe, StringBuilder는 Thread safe하지 않다. 따라서 Multi Thread 환경에서는 StringBuffer를 사용해야 한다.

## MyBatis

*  JDBC를 대체하는 Persistence framework
*  개발자가 작성한 SQL 명령어와 자바 객체를 매핑해 주는 기능을 제공
*  SQL명령을 String이 아닌 XML로 관리
*  기존 DAO 클래스에서 DB 실행을 위한 JDBC 코드를 XML로 분산한다.
*  왜 세션관리를 안해줄까? : SqlSessionFactory를 내부적으로 참조하고 있는데, 이것을 통해 자동으로 세션관리가 된다.
*  Connection Pool : DB Connection 객체를 생성하는 부분에 대한 비용과 대기시간을 줄이는 방법
*  WAS가 실행되면서 미리 일정량의 DB Connection 객체를 생성하고 pool이라는 공간에 저장한다.
*  요청에 따라 필요할 때 Pool에서 Connection 객체를 가져다 쓰고 반환한다.
*  PreparedStatement를 이용해 SQL Injection을 막는다.
*  SqlSessionFactoryBuilder : mybatis-config을 loading 하여 SqlSessionFactory 객체를 생성한다.
*  SqlSessionFactory클래스 : SqlSession 객체에 대한 팩토리 객체다. 이 객체를 통해 sqlSession 객체를 얻을 수 있다.
*  세션을 한번 생성하면 매핑구문을 실행하거나 커밋, 롤백을 하기 위해 세션을 사용할 수 있다.
*  더 이상 필요하지 않은 상태가 되면 세션을 닫는다.
*  MyBatis는 모든 쿼리를 prepared statement로 실행한다.
*  반복 실행 시 준비과정 없이 바로 실행해 좀 더 빠른 응답을 받을 수 있고, DBMS의 CPU 사용률을 줄일 수 있다.
*   DBCP(Database Connection Pool)는 Apache의 커넥션 풀 라이브러리
*  ResultMap : 반환되는 데이터의 컬럼명과 변수 명을 직접 지정해 ResultType에 지정할 때 사용

## 스프링 컨테이너

* 컨테이너는 보통 인스턴스의 생명 주기를 관리
* 생성된 인스턴스들에게 추가적인 기능을 제공하도록 한다.
* 코드의 처리과정을 위임받은 독립적인 존재
* 컨테이너는 적절한 설정만 되어있다면 누구의 도움 없이도, 코드를 스스로 참조한 뒤 알아서 객체의 생성과 소멸을 컨트롤해준다.
* 스프링 컨테이너는 스프링 프레임워크의 핵심부에 위치한다.
* 종속 객체 주입을 이용하여 애플리케이셔을 구성하는 컴포넌트들을 관리한다.
* 객체를 관리하는 컨테이너를 제공한다.
* 스프링은 컨테이너에 객체를 담아 필요할 때 객체를 가져와 사용할 수 있도록 하며, BeanFactory, ApplicationContext가 있다.
* ApplicationContext는 BeanFactory(interface)를 구현한 것이다.
* BeanFactory 인터페이스는 빈 객체를 관리하고 빈 객체간의 의존 관계를 설정하는 가장 단순한 컨테이너다.
* ApplicationContext 인터페이스는 BeanFactory 인터페이스를 상속 받은 하위 인터페이스, 빈 관리 기능 이외도 객체의 생명주기, 파일과 같은 자원처리 추상화등 추가적인 기능 제공

## IOC(Inversion of Control)

* 프로그램의 제어 흐름 구조가 바뀌는 것이다.
* 제어권이 컨테이너로 넘어가게 되는 것이 IOC
* 제어권이 컨네이너로 넘어옴으로써 DI, AOP가 가능하다.
* 인스턴스의 생성부터 소멸까지의 객체 생명주기를 스프링 컨테이너가 관리한다.
* 스프링에서 객체가 만들어지는 순서
  1. 객체 생성
  2. 의존성 객체 주입(스스로 만드는 것이 아니라 제어권을 가진 스프링에게 위임하여 스프링이 많들어 놓은 객체를 주입한다.)
  3. 의존성 객체 메소드 호출

## DI (Dependency Injection)

* 인스턴스를 자신이 아닌 외부(IOC 컨테이너)에서 생성후 주입한다.
* 기능이 변경될 때 마다 코드를 변경하는 것은 비용이 많이 들게 되므로 가급적 코드의 변화가 적어지도록 프로그램을 작성하기 위해 탄생
* 모듈 간의 결합도를 낮춰서 유연한 변경을 가능하도록 한다.
* 불필요한 의존 관계를 없애거나 줄일 수 있다.
* 각 객체를 bean 컨테이너으로 관리한다.
* IOC를 구현하는 한 가지 방법이 DI이다.

## AOP (Aspect Oriented Programming)

* 관점 지향 프로그래밍
* 로직 주입
* 다수의 모듈에 공통적으로 나타나는 부분을 관리
* 프록시 패턴

## @Autowired

* 의존 객체를 자동으로 삽입해 주는 어노테이션
* 해당 타입의 빈 객체가 존재하지 않거나, 2개 이상 존재할 경우 예외 발생
* bead 객체를 검색한 후 어노테이션이 적용된 프로퍼티, 메소드, 생성자 등에 객체를 주입해 줄때 타입을 이용하게 된다.
* @Component가 붙은 클래스들을 검사해 그중 하나를 선택해 인젝션해준다.
* private가 붙어도 접근할 수 있다.

## @Bean

* 스프링 IOC 컨테이너에 의해서 자바 객체가 만들어 지게 되면 이 객체를 스프링 빈이라고 한다.
* 기본적으로 스프링의 ApplicationContext 구현은 초기화 프로세스에서 모든 싱글톤 빈을 생성 및 설정하게 된다.
* 따라서 문제가 있을 경우 해당 빈을 사용할 때가 아닌 초기화 단계에서 바로 알 수 있다.
* 스프링 IOC 컨테이너에 의해서 인스턴스화 되어 조립되거나 관리되는 객체

## 웹 애플리케이션 동작 원리

1. 웹 애플리케이션이 실행되면 Tomcat(WAS)에 의해 web.xml이 loading된다.

2. web.xml에 등록되어 있는 ContextLoaderListener(Java Class)가 생성된다.

   ContextLoaderListener 클래스는 ServletContextListener 인터페이스를 구현하고 있으며, ApplicationContext를 생성하는 역할을 수행한다.

3. 생성된 ContextLoaderListener는 root-context.xml을 loading 한다.

4. root-context.xml에 등록되어 있는 Spring Container가 구동된다. 이 때 작성된 비즈니스 로직에 대한 부분과 DAO, VO 객체들이 생성된다.

5. 클라이언트로부터 웹 애플리케이션으로 요청이 온다.

6. DispatcherServlet이 생성된다.

   DispatcherServlet은 FrontController의 역할을 수행한다.

   클라이언트로부터 요청 온 메시지를 분석하여 알맞은 Controller에게 전달하고 응답을 받아 요청에 따른 응답을 어떻게 할 지 결정한다.

   실질적인 작업은 Controller에서 이루어진다.

   이러한 클래스들을 HandlerMapping, ViewResolver 클래스라고 한다.

7. DispatcherServlet은 servlet-context.xml을 loading 한다.

8. 두번째 Spring Container가 구됭되며 응답에 맞는 Controller들이 동작한다.

   이 때 첫번째 Spring Container가 구동되면서 생성된 DAO, VO, ServiceImpl 클래스들과 같이 알맞은 작업을 처리한다.

## OOP (Object Oriented Programming, 객체 지향 프로그래밍)

  - 캡슐화, 다형성, 상속을 이용하여 코드의 재사용성을 증가시키고, 유지보수를 감소시키는 장점을 얻기 위해서 객체들을 연결 시켜 프로그래밍 하는 것

## DDD (Domain Driven Design, 도메인 주도 설계)

## TDD (Test Driven Development, 테스트 주도 개발)

* 언제 테스트를 작성하고 수행해야 하는지에 대한 절차

1. 테스트 코드 작성
2. 작성한 테스트 코드와 기존에 작성된 다른 테스트를 수행한다. 이 시점에서 새로 추가된 테스트 코드는 실패할 것이다. 만약 실패하지 않는 다면 올바른 것을 테스트하고 있지 않은 것이므로 버그가 있다는 것이다.
3. 실패한 테스트를 성공시키기 위한 최소한의 코드를 구현
4. 실패한 테스트가 성공하는지 확인하기 위해 테스트를 재수행
5. 필요에 따라 작성한 코드를 리팩토링
6. 1번부터 다시 반복

## ArrayList

  * 상당히 빠르고 크기를 마음대로 조절 할 수 있는 배열
  * 단방향 포인터 구조로 자료에 대한 순차적인 접근에 강점(각 인덱스를 가지고 있기 때문에)
  * 내부적으로 데이터를 배열에서 관리하며 데이터의 추가, 삭제를 위해 임시 배열을 생성해 데이터를 복하는 방법, 따라서 대량, 빈번하게 데이터를 추가 삭제 하는 경우 성능 저하를 일으킬 수 있다.
  * 검색 : O(1)
  * 삽입/삭제 : O(N)

## LinkedList

  * 양방향 포인터 구조, 삭제가 빈번할 경우 빠른 성능을 보장
  * 스택, 큐, 양방향 큐 등을 만들기 위한 용도로 쓰임
  * 데이터의 추가, 삭제시 불필요한 데이터의 복사가 없어 데이터의 추가, 삭제시에 유리한 반면, 데이터의 검색시에는 처음부터 노드를 순회해야 하기 때문에 성능상 불리하다.
  * 검색 : O(N)
  * 삽입/삭제 : O(1)

## Deque

* 양쪽 끝에서 삽입과 삭제가 모두 가능
* 두 개의 포인터를 사용하여 양쪽에서 삭제, 삽입을 발생 시킨다.
* 큐 + 스택

## Index

* 읽기 성능을 향상시키기 위한 일종의 자료 구조
* Full table scan은 가장 느린 scanning 방법
* 해당 테이블의 컬럼을 색인화하여 검색시 해당 테이블의 레코드를 full scan하는것이 아니라 색인화 되어있는 Index 파일을 검색하여 검색속도 향상
* B+ 트리로 저장된다.
* index로 설정한 컬럼값이 변경되거나 추가되면, index도 업데이트 된다. 따라서 적절하게 index를 설정해야 한다.
* 데이터의 삭제, 삽입이 빈번한 경우 index의 성능이 떨어진다. 매번 b+트리를 수정해야 하기 때문이다.
* primary key는 db가 자동으로 index 기능을 설정하여 관리한다.

## Join

* 두 개 이상의 테이블을 하나의 집합으로 만드는 연산
* NL join은 중첩된 for문 방식으로 작동됨

## 다형성(Polymorphism)

* 상속을 통해 기능을 확장하거나 변경하는 것을 가능하게 해 준다.
* 같은 클래스 내에 코드의 길이를 줄여주는 것까지 도와준다.
* 하나의 메소드나 클래스가 있을 때 이것들이 다양한 방법으로 동작하는 것을 의미한다.
* ex) List
* 다형성의 조건
  * 공통의 부모 : 클래스 계층 구조(상속 관계) (List)
  * 공통의 메소드 재정의 : 메소드 재정의, 동적 바인딩 (add)
  * 부모 타입의 변수로 호출 : 업 캐스팅 후 재정의된 메소드 호출 List list = new ArrayList();

## Interface

* 추상 클래스보다 추상화 정도가 훨씬 높다.
* 추상 메소드들로만 이루어져 있다.
* 메소드의 선언만 가능하다.
* 메소드는 표준화된 공통 기능을 가진다.
* implements 키워드를 사용해 구현한다.
* 서로 다른 클래스(외부)를 연결시켜주는 장치
* 공통 작업시 충돌을 방지하기 위해서, 유지 보수의 용이를 위해 인터페이스를 사용한다.

## 추상 클래스

* 추상화는 클래스 간의 공통점을 찾아내서 공통의 조상을 만드는 작업
* 반드시 하나 이상의 추상 메소드를 가지며, 객체를 생성할 수 없다.
* 슈퍼 클래스로 사용할 수는 있으며, 추상 메소드를 사용하기 위해서는 반드시 해당 메소드를 재정의 해야만 한다.
* abstract 키워드를 사용한다.
* 자손 클래스에서 추상 메소드를 반드시 구현하도록 강요하기 위해 사용한다.

## Garbage Collection

* new 연산자를 사용하여 생성된 객체가 자동으로 제거되는 것을 Garbage Collection이라고 한다. (heap segment)
* 어떤 객체를 참조하는 변수가 하나라도 있다면, 그 객체는 사용되고 있는 것이고, 어떤 객체를 참조하는 변수가 하나라도 없다면 그 객체는 GC 된다.
* GC는 JVM에 의해서 자동으로 실행된다.
* GC가 실행될 때, 그 JVM에서 애플리케이션 thread는 모두 정지되고, 오직 GC thread만 실행된다.
* System.gc()는 GC 작업을 즉시 실행하도록 하는 메소드이다. GC는 JVM이 스스로 실행하도록 나 두는 것이 좋다.
* 변수에 NULL을 대입하는 것으로 그 객체는 GC의 대상이 된다.
* 지역 변수가 참조하는 객체들은 금방 GC 되지만, 멤버 변수가 참조한 객체들은 오랫동안 살아남는다.
* 오래된 객체의 멤버 변수가 젊은 객체를 참조하는 경우는 드물다.

## Garbage Collection 과정(알고리즘)

* mark, sweep, compact 작업으로 구성된다.
* mark
  * 더 이상 변수에 의해 참조되지 않은 객체가 garbage이다.
  * garbage를 찾는 작업이 mark이다.
  * mark 작업은 모든 변수를 검사해서 그 변수가 참조하는 객체에 표시(mark)를 한다.
* sweep
  * mark 표시가 없는 객체는 변수에 의해 참조되지 않는 garbage이다.
  * garbage 객체를 삭제하는 작업이 sweep이다.
  * 객체를 삭제하고 난 뒤 외부 단편화 현상 발생
* compact
  * mark, sweep 작업은 필수 작업이지만 compact 작업은 필수가 아니다.
  * 살아남은 객체들을 한쪽으로 몰아서, 객체들이 차지하는 영역과, 비어있는 영역으로 구분하여 메모리에 빈 영역을 확보하는 작업이다.
  * compact 작업에는 시간이 걸리지만, compact 작업 후에는 객체 생성이 빠르고, 메모리 낭비가 없다.

## JIT Compile (Just In Time Compilation)

* 자바는 jit 컴파일 방식을 사용한다.
* 바이트 코드를 실행하기 직전에 기계어 코드로 컴파일 하는 방식
* 바이트 코드를 해석해서 실행하는 것 보다(인터프리터) 기계어 코드로 변환해서 실행하는 쪽이 훨씬 더 빠르다.
* 실행할 때 마다 매번 다시 jit 컴파일을 해야 한다.
* dynamic optimization(동적 최적화)이 가능하다.
* 소스코드와 동일한 순서로 기계어 코드를 생성하지 않고, 좀더 빠르고 효율적으로 실행될 수 있도록 실행순서를 재배치하고 조정하여 기계어 코드를 생성한다.
* 실행하는 시점에 실행 순서를 재배치하고 조정하여 기계어 코드를 생성한다.

## stack overflow 공격

* 함수가 리턴할 때 되돌아갈 기계어 코드이 주소가 stack segment에 저장되고, 지역 변수도 stack segment에 저장된다는 점을 노린 공격이다.
* 데이터가 저장될 때 배열의 뒤 까지 데이터가 넘치도록 한다.(overflow)
* 이렇게 넘쳐서 저장된 데이터가 함수가 리턴 주소가 저장된 곳 까지 덮어쓰도록 한다.
* 함수가 리턴할 때, overflow 되어 변경된 주소로 리턴하게 된다.
* 공격자가 원하는 곳으로 리턴하게 되어, 다른 기계어 코드가 실행되게 된다.
* java는 JVM이 이것을 검사하기 때문에 overflow가 가능하지 않다. 대신 오류가 발생한다.(IndexOutOfBoundsException)

## C & java

* C는 절차지향, Java는 객체지향
* C는 하드웨어를 직접 제어할 수 있다.
* java는 설계적인 측면이 강조된 방식

## static

* 클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통적으로 사용해야 하는 것에 static를 붙인다.

* 인스턴스를 생성하지 않아도 사용할 수 있다.
* static이 붙은 메소드/함수는 인스턴스 변수를 사용할 수 없다.
* static은 JVM의 메소드 영역에 존재하고, JVM이 실행될 때 생성된다.
* static은 클래스가 사용되기 전에 미리 메모리에 올라간다.
* 생성할 때 마다 인스턴스가 메모리에 올라가는 것이 아니라, 고정 메모리이므로 효율적이다.
* 인스턴스를 생성하지 않고 바로 사용하기 때문에 참조속도가 빠르다.
* 메모리 낭비의 가능성이 있다.
* static 사용의 예로 싱글톤(singleton)
* GC의 대상이 되지 않는다.
* 자주 변경되지 않는 부분이나, 설정 파일 정보인 경우 사용

## Hash Table

* 데이터가 저장될 자리가 데이터 해시 값에 의해 결정되는 자료구조
* 해시 테이블의 성능은 공간을 팔아 얻어낸 것이다.
* 저장할 데이터의 값으로 저장할 위치를 계산할 수 있다.
* 평균 상수 시간에 삽입, 삭제, 검색이 가능하다.
* 매우 빠르게 자료를 저장/검색 해야 하는 경우에 유용하다.
* 충돌 해결 방법
  1. Chaning : 저장할 데이터를 링크드 리스트에 저장
  2. Linear Probing : 그 다음 칸에 저장 (1, 2, 3, 4... 뒤)
  3. Quadratic Probing : 그 다음 칸에 저장할때, 제곱칸 에 저장 (1, 4, 9, 16.. 뒤)
  4. Double Hashing : 건너뛰는 폭이 매번 다르게

## JPA (Java Persistent API)

* ORM 표준 기술로 Higernate, OpenJPA, EclipseLink, TopLink Essentials 같은 구현체가 있고 이에 대한 표준 인터페이스가 JPA다.
* 객체지향적으로 데이터를 관리할 수 있기에 비즈니스 로직에 집중할 수 있어 객체 지향 개발이 가능하다.
* 장점
  * 객체지향적으로 데이터를 관리할 수 있기 때문에 비즈니스 로직에 집중할 수 있고, 객체지향 개발이 가능하다.
  * 테이블 갱성, 변경, 관리가 쉽다.
  * 로직을 쿼리에 집중하기 보다는 객체자체에 집중할 수 있다.
  * 빠른 개발이 가능하다.
* 단점
  * 복잡한 쿼리문을 구현하기엔 MyBatis에 비해 어렵다.
  *  데이터 손실의 문제가 있을 수 있다.
  * 성능상의 문제가 있을 수 있다.

## CPU 스케줄링

* 최적의 효과(처리율 향상, 신속한 처리)을 보기 위해 (프로세스의) 계획적인 실행 순서가 필요하다. 계획적인 실행 순서가 스케줄링이다.
* 모든 프로세스에게 공정하게 배정하고, 단위 시간당 가능한 많은 양이 처리될 수 있도록 해야 한다.
* 응답 시간이 최소회해야 하고, 오버헤드를 최소화해야 한다.
* 비선점형 스케줄링 : 프로세스가 cpu에 할당되면 권한을 빼앗을 수 없다.
* 선점형 스케줄링 : 프로세스가 cpu에 할당되어도, 우선도가 높은 작업이 들어오면 권한을 빼앗긴다.

## OSI 7계층

* 프로토콜을 기능별로 나눈 것이다.
* 각 계층은 하위 계층의 기능만을 이용하고, 상위 계층에게 기능을 제공한다.

### 1계층 : Physical layer (물리 계층)

* 네트워크 하드웨어 전송 기술을 이룬다.
* 실제 장치들을 연결하기 위해 필요한 전기적, 물리적 세부 사항들을 정의한다.
* 물리적 매체를 통해 비트(Bit)흐름을 전송
* 허브, 리피터

### 2계층 : Data Link layer (데이터 링크 계층)

* point to point 간 신뢰성있는 전송을 보장하기 위한 계층
* CRC 기반의 오류 제어와 흐름 제어가 필요하다.
* 오류없이 한 장치에서 다른 장치로 프레임(Frame, 비트의 모음)을 전달하는 역할
* 3계층에서 정보를 받아 주소와 제어 정보를 헤더와 테일에 추가
* MAC, PPP
* 브릿지, 스위치

### 3계층 : Network layer (네트워크 계층)

* 여러개의 노드를 거칠때마다 경로를 찾아주는 역할을 하는 계층
* 다중 네트워크 링크에서 패킷(Packet)을 발신지로부터 목적지로 전달할 책임을 가진다.
* packets
* IP, ICMP, IGMP
* 라우터

### 4계층 : Transport layer (전송 계층) 

* End to end 의 사용자들이 신뢰성있는 데이터를 주고 받을 수 있도록 해 주어, 상위 계층들이 데이터 전달의 유효성이나 효율성을 생각하지 않도록 해준다.
* 전제 메시지를 발신지 대 목적지(종단 대 종단)간 제어와 에러를 관리한다.
* 패킷들의 전송이 유효한지 확인하고 실패한 패킷은 다시보내는 등 신뢰성 있는 통신을 보장하며, 머릿말에 세그먼트(Segment)가 포함된다.
* TCP, UDP, ARP
* 게이트 웨이

### 5계층 : Session layer (세션 계층)

* 통신 세션을 구성하는 계층으로 포트(port) 연결이라고도 할 수 있다.
* 통신장치 간의 상호작용을 설정하고 유지하며 동기화한다.
* 사용자간의 포트연결(세션)이 유효한지 확인하고 설정한다.
* SSH, TLS
* 응용간의 질서 제어

### 6계층 : Presentation (표현 계층)

* 운영체계의 한 부분으로 입력 또는 출력되는 데이터를 하나의 표현 형태로 변환한다.
* 필요한 번역을 수행하여 두 장치가 일관되게 전송 데이터를 서로 이해할 수 있도록 한다.
* 압축
* JPEG, MPEG

### 7계층 : Application layer (응용 계층)

* 사용자가 네트워크에 접근할 수 있도록 해주는 계층이다.
* 사용자 인터페이스, 전자 우편, 데이터베이스 관리 등 서비스를 제공한다.
* DHCP, DNS, FTP, HTTP, TELNET

## Spring

* IOC와 AOP를 지원하는 경향의 컨테이너 프레임워크

## 정렬 알고리즘

## Replication (레플리케이션)

* 복제, 저장소를 물리적으로 분리하여 데이터를 유지, 데이터를 이중화
* 기본적으로 Master-slave 구조
* write은 Master, read는 slave
* 쓰기 부하 분산은 불가능하지만, 일기 부하 분산은 가능
* 로그 기반으로 비동기적으로 데이터를 복제한다.
* 방식
  1. Master에서 데이터 변경이 일어나면 자신의 데이터베이스에 반영
  2. Master에서 변경된 이력을 Binary Log에 기록 후 관련 이벤트를 발생
  3. Slave IO_THREAD에서 Master 이벤트를 감지하고, Master Binary Log를 자신의 Relay Log에 기록
  4. Slave SQL_THREAD 는 Relay Log를 일고, 자신의 데이터베이스에 기록

* Master에서는 여러 세션에서 데이터 변경 처리가 가능하지만, Slave에서는 오직 하나의 SQL_THREAD에서만 데이터 변경 처리가 가능하다.

## 팩토리 패턴

* 객체를 만들어 내는 공장(Factory)을 만드는 패턴
* 객체를 만들어내는 부분을 서브 클래스에 위임하는 패턴

## 옵저버 패턴

## 템플릿 패턴

* 상위 클래스에서 전체적인 구조를 결정하고, 하위 클래스에서 그 구체적인 내용을 결정하는 패턴
* 안드로이드의 onCreate()
* 추상 메소드의 실제 구현

## HTTP(HyperText Transfer Protocol)

* WWW 상에서 정보를 주고받을 수 있는 프로토콜
* HTML 문서를 주고 받는데에 쓰인다.
* TCP, UDP 프로토콜을 사용, 80번 포트 사용
* 서버와 응답, 요청 방식으로 작동

## HTTP 동작 순서

1. 웹 브라우저에 사용자가 URL 주소 입력
2. DNS 서버에 웹 서버의 호스트 이름을 주고 IP 주소를 얻어온다.
3. 웹 서버와 TCP 연결 시도 (3 way handshake)
4. 서버에게 명령 전송(get, post, put, delete...)
5. 서버가 클라이언트에게 데이터를 회신
6. 서버와 클라이언트같 연결 해제 (4 way handshake)
7. 웹 브라우저가 웹 문서를 출력

## 3 Way Handshake

* TCP 통신을 하기 위한 연결 방식
* 최초에 Server에서 열려있는 포트는 LISTEN, Client에서는 CLOSED

1. Client에서 Server에 연결 요청을 하기위해 SYN 데이터를 보낸다.

2. Server에서는 해당 포트는 LISTEN 상태에서 SYN 데이터를 받고, SYN_RCV로 상태가 변경된다.

   그리고 Client에게 요청을 정상적으로 받았다는 대답(ACK)과 Client에게 포트를 열어달르는 SYN을 보낸다.

3. Client에서는 SYN + ACK를 받고 ESTABLISHED로 상태를 변경하고 서버에 요청을 잘 받았다는 ACK를 전송한다.

4. ACK를 받은 서버는 상태가 ESTABLISHED로 변경된다.

## 4 Way Handshake

* TCP 통신을 종료하기 위한 방식
* 정상적인 종료 상황
* 최초에 서로 통신 상태이기 때문에 Server, Client 모두 ESTABLISHED 상태

1. 통신을 종료하고자 하는 Client가 Server에게 FIN을 보내고, 자신은 FIN_WAIT_1 상태로 대기한다.

2. FIN을 받은 서버는 해당 포트를 CLOSE_WAIT로 바꾸고 잘 받았다는 ACK을 Client에게 보내고,  그와 동시에 Server에서는 해당 포트에 연결되어있는 애플리케이션에게 Close()를 요청한다.

3. ACK를 받은 Client는 FIN_WAIT_2 상태로 변경한다.

4. Close() 요청을 받은 애플리케이션은 종료 프로세스를 진행시켜 최종적으로 close()가 되고 Server는 FIN을 Client에게 전송후 자신은 LAST_ACK로 상태가 변경된다.

5. FIN_WAIT_2에서 Server가 연결을 종료했다는 신호를 기다리다가 FIN을 받으면 잘 받았다고 ACK를 Server에게 전송하고 Client은 TIME_WAIT로 상태를 바꾼다.

   TIME_WAIT 상태는 일정 시간이 지나면 CLOSED로 변경된다.

   최종 ACK를 받은 서버는 자신의 포트도 CLOSED로 닫게 된다.

* 비 정상적인 종료 상황

* CLOSE_WAIT 상태 : 애플리케이션에서 Close()를 처리하지 못하면 서버 포트는 CLOSE_WAIT 상태로 계속 대기하게 된다. CLOSE_WAIT 상캐가 statement에 많아지게 되면, Hang이 걸려 더이상 연결을 하지 못하게 된다.

* FIN_WAIT_1 상태 : Server에 종료 요청을 했는데, ACK를 받지 못한 상태로 기다리고 있다. 서버를 찾을 수 없거나, 네트워크 방화벽의 문제일 수 있디. FIN_WAIT_1 상태는 일정 시간이 지나 TIME OUT이 되면 자동으로 닫힌다.

* FIN_WAIT_2 상태 : Client가 Server에 종료를 요청한 후 Server에서 요청을 접수했다고 ACK를 받았지만, Server에서 종료를 완료했다는 FIN 상태를 받지 못하고 기다리는 상태이다. 

  양방의 두번의 통신이 이미 이루어졌기 때문에 네트워크의 문제는 아니라고 판단한다.

  Server에서 CLOSE를 처리하지 못하는 경우일 수도 있다.

  FIN_WAIT_2는 일정 시간이 지나 TIME_OUT이 되면 스스로 CLOSE하게 된다.

* TIME OUT이 길어서 많은 수의 소켓이 늘어만 난다면 메모리 부족의 현상이 발생할 수 있다.

## Generic

* 다양한 타입의 객체들을 다루는 메소드나 컬렉션 클래스에 컴파일 시에 타입 체크를 해 주는 기능이다.
* 클래스 내부에서 사용할 데이터의 타입을 나중에 인스턴스를 생성할 때 확정한다.
* 객체의 타입을 컴파일 시에 체크하기 때문에 객체 타입의 안전성을 높이고, 형 변환의 번거로움이 줄어든다.
* 타입 안정성을 제공한다. 의도하지 않은 타입의 객체를 저장하는 것을 막고, 저장된 객체를 꺼내올 때 원래의 타입과 다른 타입으로 형 변환되어 발생할 수 있는 오류를 줄여준다.
* 타입체크와 형 변환을 생략할 수 있으므로 코드가 간결해진다. 사용할 객체 타입을 미리 명시해줌으로써 형 변환을 하지 않아도 된다.
* 다형성을 사용하는 경우에 부모 타입을 지정함으로써 여러 종류의 객체를 저장할 수 있다.
* 복수의 제너릭을 사용할 시엔 , 를 사용한다. <T, S>
* 참조 데이터 타입에 대해서만 사용할 수 있다.

## 상태코드

* 200 : 성공
* 201 :  작성됨
* 400 : 
* 500 : 서버 내부 에러

## 자바 8

* 람다식
* 스트림 API

## Rest(Representational State Transfer)

* 네트워크 아키텍처 원리의 모음
* 자원을 정의하고, 자원에 대한 주소를 지정하는 방법 전반
* 자원의 식별
* 메시지를 통한 리소스의 조작

## API(Application Programming Interface)

* 응용 프로그램에서 사용할 수 있도록 만든 인터페이스
* API를 통해 URI를 제공

## URI(Uniform Resource Identifier)

* 통합 자원 식별자
* URI가 어떤 자원의 위치를 의미하고, Method가 그 위치에 대한 행위를 뜻한다.
* URI는 DB의 논리적, 물리적 설계와 상관없다.

## ORM(Object Relational Mapping)

* 객체와 관계형 데이터베이스와의 설정을 자동으로 해준다.
* 실제 데이터와 객체와의 개념적 일치하지 않는 부분을 자동으로 매핑해 준다.
* 관계형 데이터베이스의 데이터를 객체형 데이터처럼 사용할 수 있다.
* MyBatis, iBatis, JPA, Hibernate
* 장점
  * 객체 지향적인 코드로 인해 더 직관적이고 비즈니스 로직에 집중할 수 있게 도와준다.
  * 선언문, 할당, 종료 같은 부수적인 코드가 줄어든다.
  * 재사용 및 유지보수의 편리성이 증가한다.
  * DBMS에 대한 종속성이 줄어든다.
  * SQL의 절차적이고 순차적인 접근이 아닌 객체 지향적인 접근으로 인해 생산성이 증가한다.
* 단점
  * 모든 기능을 ORM으로만 작성하기에는 쿼리가 복잡해지면 쓰기 어렵다.
  * 많은 수의 레코드를 잦은 빈도로 벌크 수행
  * 완벽한 ORM으로만 서비스를 구현하기가 어렵다.
  * 프로시저가 많은 시스템에선 ORM의 객체 지향적인 장점을 활용하기 어렵다.

## Transcation (트랜잭션)

* 데이터베이스 관리 시스템 또는 유사한 시스템에서 상호작용의 단위이다.
* 유사한 시스템이란 트랜잭션이 성공과 실패가 분명하고 상호 독립적이며 일관되고 믿을 수 있는 시스템을 의미한다.
* ACID는 데이터베이스 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질을 가리키는 약어
* Atomicity 원자성 : 중간 단계까지 실행되고 실패하는 일이 없도록 하는 것이다.
* Consistency 일관성 : 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 유지하는 것을 의미한다. 
* Isolation 고립성 : 트랜잭션을 수행 시 다른 트랜잭션의 연산 작업이 끼어들지 못하도록 보장하는 것을 의미한다. 트랜잭션 밖에 있는 어떤 연산도 중간 단계의 데이터를 볼 수 없음을 의미한다.
* Durability 지속성 : 성공적으로 수행된 트랜잭션은 영원히 반영되어야 함을 의미한다. 시스템 문제, DB 일관성 체크 등을 하더라도 유지되어야 함을 의미힌다. 전형적으로 모든 트랜잭션은 로그로 남고 시스템 장애 발생 전 상태로 되돌릴 수 있다. 트랜잭션은 로그에 모든 것이 저장된 후에만 commit 상태로 간주될 수 있다.

## 메모리 단편화

* RAM에서 메모리의 공간이 작은 조각으로 나뉘어져 사용가능한 메모리가 충분히 존재하지만 할당(사용)이 불가능한 상태를 보고 메모리 단편화가 발생했다고 한다.

1. 내부 단편화(Internal Fragmentation)
   * 메모리를 할당할 때 프로세스가 필요한 양보다 더 큰 메모리가 할당되어서 프로세스에서 사용하는 메모리 공간이 낭비되는 상황
2. 외부 단편화(External Fragmentation)
   * 메모리가 할당되고 해제되는 작업이 반복될 때 작은 메모리가 중간중간 존재하게 된다. 이 때 중간중간에 생긴 사용하지 않는 메모리가 많이 존재해서 총 메모리 공간은 충분하지만 실제로 할당할 수 없는 상황

## 메모리 단편화 문제 해결 방법

1. 페이징(Paging) 기법
   * 가상 메모리 사용, 외부 단편화 해결, 내부 단편화 존재
   * 보조 기억 장치를 이용한 가상메모리를 같은 크기의 블록으로 나눈 것을 페이지라고 정의
   * RAM을 페이지와 같은 크기로 나눈 것을 프레임이라고 정의
   * 사용하지 않는 프레임을 페이지에 옮기고, 필요한 메모리를 페이지 단위로 프레임에 옮기는 기법
   * 페이지와 프레임을 대응시키기 위해 page mapping 과정이 필요해서 paging table을 만든다.
   * 페이징 기법을 사용하면 연속적이지 않은 공간도 활용할 수 있기 때문에 외부 단편화 문제를 해결할 수 있다.
   * 페이지 단위에 알맞게 꽉 채워 쓰는 것이 아니므로 내부 단편화 문제는 여전히 존재
   * 페이지 단위를 작게하면 내부 단편화 문제도 해결할 수 있겠지만 대신 page mapping 과정이 많아지므로 오히려 효율이 떨어질 수 있다.
2. 세그멘테이션(Segmentation) 기법
   * 가상 메모리 사용, 내부 단편화 해결, 외부 단편화 존재
   * 가상 메모리를 서로 크기가 다른 논리적 단위인 세그먼트로 분할해서 메모리를 할당하여 실제 메모리 주소로 변환하게 된다.
   * 각 세그먼트는 연속적인 공간에 저장되어 있다.
   * 세그먼트들의 크기가 다르기 때문에 미리 분할해 둘 수 없고, 메모리에 적재될 때 빈 공간을 찾아 할당하는 기법이다.
   * mapping을 위해 세그먼트 테이블이 필요하다.
   * 프로세스가 필요한 메모리 만큼 할당해주기 때문에 내부단편화는 일어나지 않으나 여전히 프로세스가 메모리를 해제할때 발생하는 외부 단편화 문제는 여전히 존재한다.
3. 메모리 풀(Memory Pool)
   * 필요한 메모리 공간을 필요한 크기, 개수 만큼 사용자가 직접 지정하여 미리 할당받아 놓고 필요할 때 마다 사용하고 반납하는 기법
   * 미리 공간을 할당해놓고 가져다 쓰고 반납하기 때문에 할당과 해제로 인한 외부 단편화가 발생하지 않는다.
   * 필요한 크기 만큼 할당해 놓기 때문에 내부 단편화 또한 생기지 않는다.
   * 메모리 단편화로 인한 메모리 낭비량보다 메모리 풀을 만들었지만 쓰지 않았을 때 메모리 양이 커질 경우 사용하지 않아야 한다.
   * 메모리의 할당, 해제가 잦은 경우에 메모리 풀을 쓰면 효과적이다.
   * 미리 할당해 놓고 사용하지 않는 순간에도 계속 할당해놓으므로 메모리 누수가 있는 방식이다.
4. 메모리 풀 구현 방법
   * 큰 메모리 블록(페이지)을 힙으로 부터 할당
   * 할당 받은 페이지를 각 객체의 크기의 블록으로 나눔
   * 각 객체를 위한 블록을 순차적으로 링크
   * 이때 현 시점에서 할당할 블록을 특정 포인터가 가리키게 함
   * 메모리 요청이 생기면 현재 헤더 포인터가 가리키는 블록을 반환한다.
   * 사용되는 메모리가 해제되어 메모리 풀로 돌아올 경우 헤더 포인터는 그 블록을 가리키고 방금 전 까지 헤더 포인터가 가리키던 블록을 돌아온 블록의 다음 포인터가 가리키게 한다.

## MySql Engine

* InnoDB
  * 따로 스토리지 엔진을 명시하지 않으면 기본으로 설정되는 스토리지 엔진이다. 
  * transacation-safe하며, 커밋과 롤백, 데이터 복구 기능을 제공하므로, 데이터를 효과적으로 보호할 수 있다.
  * 기본 page size 는 16k
* MyISAM
  * 트랜잭션을 지원하지 않고, table-level locking을 제공한다. 따라서 multi-thread 환경에서 성능이 저하될 수 있다.
  * 특정 세션이 테이블을 변경하는 동안 테이블 단위로 lock이 잡힌다.
* Archive
  * 로그수집에 적합한 엔진이다.
  * 데이터가 메모리상에서 압축되고 압축된 상태로 디스크에 저장이 되기 때문에 row-level locking이 가능하다.
  * 한번 insert된 데이터는 update, delete를 사용할 수 없고, 인덱스를 지원하지 않는다.
  * 거의 가공하지 않을 원시 로그 데이터를 관리하는데에 효율적이고, 테이블 파티셔닝도 지원한다.
  * 트랜잭션을 지원하지 않는다.

## Git

* commit
  * 파일 및 디렉터리에 대한 변경 사항을 Git의 인덱스에 기록한다.
* push
  * 로컬 인덱스 및 오브젝트 변경 정보를 사용하여 원격 저장소를 업데이트한다.

## Get & Post

* Get은 가져오는 것이다.
* Get은 값이 ?뒤에 쿼리 스트링으로 붙는다.
* Get은 URL에 이어 붙기 때문에 많은 양의 데이터를 보내기 어렵다.
* Get은 Select적인 성향을 가지고 있다.
* Post는 수행하는 것이다.
* Post는 Body에 담아 데이터가 전송된다.
* Post는 form을 이용해서 submit 하는 형태이다.
* Post는 서버의 값이나 상태를 바꾸기 위해서 사용한다.

## Spring 과 SpringBoot의 차이점

## 이진 트리

* 각각의 노드가 최대 두 개의 자식 노드를 가지는 트리

## 페이지 교체 전략(캐시 알고리즘)

* OPT(OPTimal Replacement, 최적)
  * 페이지 사용 횟수를 정확히 예측하여 교체하는 방법
  * 앞으로 가장 오랫동안 사용되지 않을 페이지와 교체
  * 가상 이상적이지만 실현 가능성은 희박하다.
  * 페이지 폴트 횟수가 가정 적으므로 성공률이 가장 크다.
* FIFO
  * 가장 오래된 페이지와 교체한다.
* LRU(Least Recently Used)
  * 참조된지 가장 오래된 페이지를 대체 대상으로 선정한다.
* LFU(Least Frequently Used)
  * 페이지별로 사용(참조)된 횟수를 기억할 참조 변수를 확보한 
* NUR(Not Used Recently)
  * 페이지당 두 개의 정보 비트(참조 비트 + 변형 비트)를 이용하여 교체하는 방법이다.
* PFF(Page Fault Frequently)
  * 자주 참조하는 페이지들은 주기억 장치에 미리 적재하여 페이지 폴트가 최소가 되도록 해야 한다.
* Second Change(FIFO 2차)
  * 가장 오래된 페이지를 제거하기 전에 기회를 한번 더 준다.
  * FIFO 순으로 유지시키면서 LRU 근사 알고리즘처럼 참조 비트를 가지게 한다.

## CORS(Cross-Origin Resource Sharing)

* 처음 전송되는 리소스의 도메인과 다른 도메인으로부터 리소스가 요청될 경우 해당 리소스는 cross-origin HTTP 요청에 의해 요청된다.
* 보안 상의 이유로 브라우저들은 스크립트내에서 초기화되는 cross-origin HTTP 요청을 제한한다.
* API 서버와 프론트엔드 서버를 별도로 구현하는 경우 발생한다.(서버의 도메인과 클라이언트의 도메인이 다르다)
* cross domain : 웹 브라우저에서 Ajax 등을 통해 다른 도메인의 서버에 요청할 경우 발생
* CORS : 서버의 자원을 외부 도메인에서 접근을 허용하는 매커니즘
* Preflight Request
  * 클라이언트(웹 브라우저)는 서버에게 2번의 요청을 보낸다.
  * 첫 번째 요청은 Preflight Request이다.
  * preflight 요청을 OPTIONS method로 전송한다.
  * 이 요청을 받은 서버는 정상적인 요청인지 판단하여 Response에 허용 가능한 도메인, 메소드, 헤더등을 설정하여 응답한다.
  * 두번째 요청이 본 요청이다.
* Access-Control-Allow-Origin
  * Access-Control-Allow-Origin의 헤더 값으로 지정된 도메인으로부터의 요청만 서버의 리소스에 접근이 가능
* Spring에서의 해결방법
  1. Spring Security의 cors() 설정
  2. Filter에서 response의 헤더값을 설정
  3. Intercepter에서 response의 헤더값을 설정
  4. @CrossOrigin 어노테이션 이용
  5. WebConfigurerAdapter을 상속받아 java config 파일 작성
  6. cors 설정에 허용 도메인 추가

## CSRF(Cross-Site Request Forgery, XSRF)

* 사이트 간 요청 위조
* 웹 사이트 취약점 공격의 하나
* 사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위(수정, 삭제, 등록 등)를 특정 웹 사이트에 요청하게 하는 공격을 의미한다.
* 특정 웹사이트가 사용자의 웹 브라우저를 신용하는 상태를 노린 것이다.
* 사용자가 웹사이트에 로그인한 상태에서 사이트간 요청 위조 공격 코드가 삽입된 페이지를 열면, 공격 대상이 되는 웹사이트는 위조된 공격 명령이 믿을 수 있는 사용자로부터 발송된 것으로 판단하게 되어 공격에 노출된다.
* 예방법
  * XSS 예방
  * CSRF 토큰을 사용

## HTTPS(HyperText Transfer Protocol over Secure Socket Layer)

* HTTP의 보안이 강화된 버전
* 소켓 통신(TCP)에서 일반 텍스트 대신에 SSL이나 TLS 프로토콜을 통해 세션 데이터를 암호화한다.
* 데이터의 적절한 보호를 보장한다.
* 통신이 느려진다.(클라이언트 요청 시 SSL에 필요한 통신이 추가된다.)
* 암호화 복호화 계산을 하기 때문에 서버나 클라이언트의 리소스를 추가적으로 소비한다.
* 증명서를 구입해야 한다.

## SSL(Secure Sockets Layer)

* 웹 브라우저와 웹 서버 사이에 암호화된 통신을 구현
* SSL 인증서는 클라이언트와 서버간의 통신을 제 3자가 보증해주는 전자화된 문서다.
* 통신 내용이 공격자에게 노출되는 것을 막을 수 있다.
* 클라이언트가 접속하겨는 서버가 신뢰 할 수 있는 서버인지를 판단할 수 있다.
* 통신 내용의 악의적인 변경을 방지할 수 있다.
* 클라이언트가 접속한 서버가 신뢰 할 수 있는 서버임을 보장한다.
* SSL 통신에 사용할 공개키를 클라이언트에게 제공한다.
* CA : 인증버가 맞는지 보장하는 역할
* SSL 인증서의 내용
  * 서비스의 정보(인증서를 발급한 CA, 서비스의 도메인 등)
  * 서버 측 공개키(공개키의 내용, 공개키의 암호화 방법)
* 동작 방법
  1. 웹 브라우저에서 SSL로 암호화된 페이지 요청(https://)
  2. 웹 서버에서 공개키가 포함된 인증서 전송
  3. 웹 브라우저에서 인증서가 자신이 신용있다고 판단한 CA로 부터 서명된 것인지 확인한다. 또한 날짜가 유효한지, 인증서가 접속하려는 사이트와 관련되어 있는지 확인한다.
  4. 공개키를 사용해서 랜덤 대칭 암호화키를 비롯한 URL, http 데이터들을 암호화해서 전송한다.
  5. 웹 서버에서 대칭키를 이용해서 랜덤 대칭 암호화키와 URL, http 데이터를 복호화한다.
  6. 웹 서버에서 요청받은 URL에 대한 응답을 웹 브라우저로부터 받은 랜덤 대칭 암호화키를 이용하여 암호화 해 브라우저로 전송한다.
  7. 웹 브라우저에서 대칭키를 이용해서 http 데이터와 html 문서를 복호화하고, 화면에 정보를 뿌려준다.

## 교착 상태(Deadlock, 데드락)

* 두 개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태
* 교착상태가 발상할 조건
  1. 상호 배제
  2. 점유와 대기
  3. 비선점
  4. 순환 대기
* 교착상태 해결 방안
  1. 교착상태 예방: 교착상태가 절대 발생하지 않도록 사전에 조치를 취하는 방법
  2. 교착상태 회피: 프로세스가 자원을 요구할 때 시스템이 안정 상태를 유지할 수 있는 프로세스의 자원 요청만을 할당해 주는 방안
  3. 교착상태 회복: 실행을 중단하거나 점유 중인 자원을 빼앗을 프로세스를 찾는 일, 가능한 손실이 적은 쪽을 선택해야 한다.

## 대칭키 암호화 방식

* 암호화와 복호화에 같은 암호키를 쓰는 알고리즘
* 암호화측과 복호화측이 암호키를 공유
* 계산 속도가 빠르다.
* 수신자와 송신자가 같은 대칭키를 가져야 한다.

## 공개키 암호화 방식

* 인코딩과 디코딩에 다른 키를 사용하는 알고리즘
* A키로 암호화를 하면 B키로 복호화를 할 수 있고, B키로 암호화를 하면 A키로 복호화를 할 수 잇는 방식
* 공개키와 비밀키가 존재
* 공개키는 누구나 알 수 있지만 그에 대응하는 비밀 키는 소유자만 알 수 있어야 한다.
* 공개 키 암호: 특정한 비밀 키를 가지고 있는 사용자만 내용을 열어볼 수 있음
* 공개 키 서명: 특정한 비밀 키로 만들었다는 것을 누구나 확인 할 수 있음

## Semaphore

* 스레드의 실행 순서, 임계 영역에 접근 가능한 스레드를 지정할 수 있다.
* 카운트 값이 0이면 진입이 가능하고, 이상이면 진입이 불가능하다.
* 공유된 자원의 데이터를 여러 프로세스가 접근하는 것을 막는 것

## Mutex

* 임계 영역에 무조건 접근 하지 못하도록 lock을 건다.
* 단 하나만 접근이 가능하다.
* 끝나면 언락된다.
* 스레드의 순서를 보장 못한다.
* 공유된 자원의 데이터를 여러 쓰레드가 접근하는 것을 막는 것

## Spring Data

* Spring에서 제공하는 라이브러이 묶음
* Jpa는 Spring Data의 한 제품

## 객체 로딩

* 즉시 로딩(EAGER LOADING)
  * @ManyToOne(fetch = FetchType.EAGER)
  * 엔티티를 조회할 때 연관된 엔티티도 함께 조회한다.
* 지연 로딩(LAZY LOADING)
  * @ManyToOne(fetch = FetchType.LAZY)
  * 엔티티를 조회할 때 연관된 엔티티를 실제 사용할 때 조회한다.
  * 조회한 부모(조인의 주체)의 엔티티의 자식(조인 될) 변수에 프록시 객체를 넣어둔다.
  * 프록시 객체는 실제 사용되지 않고, 실제로 사용할 때 데이터베이스를 조회해서 프로그시 객체를 초기화한다.
* @ManyToOne, @OneToOne : 즉시 로딩(FetchType.EAGER)
* @OneToMany, @ManyToMany : 지연 로딩(FetchType.LAZY)

## Synchronous

* 순서대로 코드가 실행된다.
* 상위의 메소드,함수가 끝나야 하위의 메소드, 함수가 실행된다.

## Asynchronous

* 순서대로 코드가 실행되지만, 결과가 순서대로라고 보장할 수 없다.
* 상위의 메소드, 함수를 실행하고, 바로 하위의 메소드, 함수를 실행한다.
* 실행시킨 함수로 부터 반환값이 전달되면, 현재 진행한 작업을 중단하고, 반환값을 처리한다.

## Blocking

* 스레드가 작업이 종료될 때 까지 대기한다.
* 호출된 함수가 작업이 종료될 깨 까지 호출한 함수에게 제어권을 넘겨주지 않고 대기하게 만든다.

## Non Blocking

* 스레드가 작업이 종료될 때 까지 기다리지 않는다.
* 호출된 함수가 바로 리턴해서 호출한 함수에게 제어권을 넘겨주고, 호출한 함수가 다른 일을 할 기회를 줄 수 있다.

## IO

* Input/Output

## NIO

* java의 NIO는 New Input / Output
* NIO의 File 관련 NIO는 모두 Blocking I/O

## Netty

* NIO 클라이언트 서버 프레임워크

## Promise

* 자바스크립트 비동기 처리에 사용되는 객체

## 해시(Hash)와 암호화(Encryption)의 차이

* 해시는 단방향 암호화 기법
* 암호화는 양방향 암호화 기법
* 암호화는 복호화기능도 있다.
* 해시 알고리즘은 특정 입력값에 대해 항상 같은 해시 값을 리턴한다.
* 해시된 값은 입력이 다른 값이지만, 리턴값은 같을 수 있다.
* 비밀번호에 솔트(salt) 값을 넣는 방법도 있고, 해시 함수를 여러번 돌리는 방법도 있다.

## 접근제어자 Default

* 아무런 접근 제한자를 명시하지 않으면 default 값이 된다.
* 동일한 패키지 내에서만 접근이 가능하다.
* 자바 8에서 인터페이스에 default 메소드를 사용할 수 있게 됬다.
* 이전에 개발한 구현 클래스를 그대로 사용하고 변경하지 않으면서, 새롭게 개발하는 클래스는 디폴트 메소드를 활용해 새로운 기능을 만들수 있는 것이다.
* 만약 후에 인터페이스에 새로운 기능을 추가해야 할 경우
  * 기존 인터페이스의 구현체였던 클래스에도 해당 메소드의 내용을 구현해줘야 한다는 문제점이 발생
  * 구현체를 수정할 여견이 안된다면 인터페이스에 새로운 추상 메소드를 추가할 수 없게 된다.
  * 이런 경우 인터페이스에 디폴트 메소드를 선언하고, 필요에 따라서 새로 구현하는 구현체에서 디폴트 메소드를 재정의해서 구현하면 된다.

## IDS (Intrusion Detection Sysyem, 침입 탐지 시스템)

* 탐지적, 사후 조치

## IPS (Intrusion Prevention System, 침입 방지 시스템)

* 예방적, 사전 조치