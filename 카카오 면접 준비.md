# 카카오IX 면접 준비

## 인터페이스

* 클래스들이 구현해야 하는 동작을 지정하는데 사용되는 추상형
* 규약, 규제
* 추상 클래스의 극단적인 경우
* 인터페이스도 상속이 가능하다.
* 클래스와 달리 다중 상속이 가능하다.
* 객체의 내부 구조를 알 필요 없이 인터페이스의 메소드만 알고 있으면 된다는 장점
* 다형성을 이용한 인터페이스의 구현 객체를 손쉽게 교체할 수 있다.
* 자바 8에서 인터페이스가 가질 수 있는것
  * 상수 필드(public static final) : 기존, 생략 가능
  * 추상 메소드(public abstract)  : 기존 ,생략 가능
  * 디폴트 메소드(public default) : 추가
    * 이전에 개발한 구현 클래스를 그대로 사용하지 않고 변경하지 않으면서, 새롭게 개발하는 클래스는 디폴트 메소드를 활용해 새로운 기능을 만들 수 있다.

## 다형성

* 하나의 메소드나 클래스가 상황에 따라 다양한 방법으로 동작하는 것을 의미한다.
* 오버로딩은 다형성의 가장 대표적인 예
* 다형성 조건
  * 공통의 부모
  * 공통의 메소드 재정의
  * 부모 타입의 변수로 호출

## 제네릭

* 다양한 타입의 객체들을 다루는 메소드나 컬렉션 클래스에 컴파일 시의 타입 체크를 해주는 기능이다.
* 클래스 내부에서 사용할 데이터 타입을 나중에 인스턴스를 생성할 때 확정하는 것을 제네릭이라 한다.
* 타입 안정성을 제공한다.
* 타입체크와 형변환을 생략할 수 있으므로 코드가 간결해진다.

## JVM

* 자바 애플리케이션을 클래스 로더를 통해 읽어 들려 자바 API와 함께 실행하는 것이다.
* 자바 바이트 코드를 실행할 수 있는 주체이다.
* 인터프리터나 JIT 컴파일 방식으로 다른 컴퓨터 위에서 자바 바이트 코드를 실행할 수 있도록 구현한다.
* 자바 바이트코드는 플랫폼에 독립적이다.
* 모든 JVM은 JVM 규격에 정의된 대로 자바 바이트 코드를 실행한다.
* 스택 기반이다.
* 대다수의 명령어가 스택 선두에서 피연산자를 택하고 결과는 다시 스택에 넣는다.
* 포인터를 지원하지만, C 처럼 주소 값을 임의로 조작이 가능한 포인터 연산은 불가능하다.
* GC를 사용한다.
* 메모리 관리가 가능하다.
* 

## GC

## Spring

* 스스로 발전하는 프레임워크
* 스프링 개발 철학 중 하나는 "항상 프레임워크 기반의 접근 방법을 사용하라"
* 스프링 기능의 대부분은 핵심 기능을 확장해서 발전시킨 결과물이다.
* 단순함과 유연성을 중요 가치로 생각한다.
* 정의 : 자바 엔터프라이즈 개발을 편하게 해주는 오픈소스 경량급 애플리케이션 프레임워크

## Spring Bean Life Cycle

1. 빈 인스턴스화 및 DI
   1. XML파일 / 자바 설정 클래스 / 어노테이션에서 빈 정의를 스캔
   2. 빈 인스턴스 생성
   3. 빈 프로퍼티에 의존성 주입
2. 스프링인지 여부 검사
   1. 빈이 BeanNameAware 인터페이스 구현 시 setBeanName() 호출
   2. 빈이 BeanClassLoaderAware 인터페이스 구현 시 setBeanClassLoader() 호출
   3. 빈이 ApplicationContextAware 인터페이스 구현 시 setApplicationContext() 호출
3. 빈 생성 생명주기 콜백
   1. @PostConstruct 어노테이션 적용 메소드 호출
   2. 빈이 InitializingBean 인터페이스 구현 시 afterPropertiesSet() 호출
   3. 빈이 init-method 정의하면 지정한 메소드 호출
4. 빈 소멸 생명주기 콜백
   1. @PreDestory 어노테이션 적용 메소드 호출
   2. 빈이 DispoableBean 인터페이스 구현 시 destory() 호출
   3. 빈이 destroy-method 정의하면 지정한 메소드 호출

## Spring Container

* 컨테이너는 보통 인스턴스의 생명 주기를 관리하며, 생성된 인스턴스들에게 추가적인 기능을 제공하도록 하는것이다.
* 작성한 코드의 처리과정을 위임받은 독립적인 존재이다.
* 적절한 설정만 되어있다면 누구의 도움없이도 프로그래머가 작성한 코드를 스스로 참조한 뒤 알아서 객체의 생성과 소멸을 컨트롤해준다.
* 스프링 컨테이너는 IOC를 사용해 어플리케이션을 구성하는 빈/컴포넌트 들을 관리한다.
* 스프링 컨테이너는 두 종류가 있다.
  1. BeanFactory
     * DI의 기본사항을 제공하는 가장 단순한 컨테이너
     * 팩토리 패턴을 구현한 것
     * 빈을  생성하고 분배하는 책임을 지는 클래스
     * 빈의 정의는 즉시 로딩하지만, 빈 인스턴스 생성은 Lazy Loading한다.
     * **처음으로 getBean()이 호출된 시점에서야 해당 빈을 생성(Lazy Loading)**
  2. ApplicationContext
     * BeanFactory 인터페이스를 상속 받은 하위 인터페이스
     * BeanFactory와 유사한 기능을 제공하지만 좀 더 많은 기능을 제공한다.
     * **국제화가 지원되는 텍스트 메시지를 관리해준다.**
     * **이미지같은 파일 자원을 로드 할 수 있는 포괄적인 방법을 제공한다.**
     * **Listener로 등록된 Bean에게 이벤트 발생을 알려준다.**
     * **Context 초기화 시점에서 모든 싱글톤 빈을 미리 로드한 후 어플리케이션 기동 후에는 빈을 지연 없이 얻을 수 있다.(미리 빈을 생성해 놓아 빈이 필요할 때 즉시 사용할 수 있도록 보장한다.)**
* 컨테이너 생명 주기
  1. 생성
  2. 설정
  3. 사용
  4. 종료

## Spring Data JPA

* JPA(Java Persistent API) : 자바 영속성 
* 도메인 주도 개발이 가능하다.
* 어플리케이션의 코드가 SQL 데이터베이스 관련 코드에 잠식 당하는 것을 방지하고 도메인 기반의 프로그래밍으로 비즈니스 로직을 구현하는데 집중할 수 있다.
* 개발 생산성이 좋으며, 데이터베이스에 독립적인 프로그래밍이 가능하고, 타입 세이프한 쿼리 작성 그리고 Persistent Context가 제공하는 캐시 기능으로 성능 최적화까지 가능하다.
* 영속성 관리와 ORM을 위한 표준 기술이다.
* ORM 표준 기술로 Hibernate, OpenJPA, EclipseLink, TopLinke Essentials 과 같은 구현체가 있고 이에 표준 인터페이스가 JPA이다.

## Bean

* Spring Container가 생성하고 관리하는 어플리케이션 객체

## Servlet

* 자바를 사용하여 웹 페이지를 동적으로 생성하는 서버측 프로그램
* 웹 서버의 성능을 향상하기 위해 사용되는 자바 클래스의 일종이다.
* JSP와 비슷한 점이 있지만, JSP는 html 문서 안에 자바 코드를 포함하고 있지만, 서블릿은 자바 코드안에 HTML을 포함하고 있다.
* 외부 요청마다 스레드로 응답하므로 가볍다.

## Dispatcher Servlet

* 해당 애플리케이션으로 들어오는 요청을 모두 핸들링해준다.
* Dispatcher Servlet을 이용한다는 것은 스프링에서 제공하는 @MVC를 이용하겠단 뜻
* HTTP 프로토콜을 통해 들어오는 모든 요청을 프레젠테이션 계층의 제일 앞에 둬서 중앙 집중식으로 처리해주는 프론트 컨트롤러(Front Controller)
* 공통 처리 작업을 Dispatcher Servlet이 처리한 수, 적절한 세부 컨트롤러로 작업을 위임해 준다.
* web.xml의 역할을 상당히 축소시켜주었다.

## Java Bean

* 원래는 비주얼 툴에서 조작 가능한 컴포넌트를 말한다.
* 간단히 빈이라고 부르기도 한다.
* 현재는 다음 두 가지 관계를 따라 만들어진 오브젝트를 가리킨다.
  * 디폴트 생성자 : 자바빈은 파라미터가 없는 디폴트 생성자를 갖고 있어야 한다. 툴이나 프레임워크에서 리플렉션을 이용해 오브젝트를 생성하기 때문에 필요하다.
  * 프로퍼티 : 자바빈이 노출하는 이름을 가진 속성을 프로퍼티라고 한다. 프로퍼티는 set으로 시작하는 수정자 메소드(setter)와 get으로 시작하는 접근자 메소드(getter)를 이용해 수정 또는 조회할 수 있다.

## DAO(Data Access Object)

* DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트를 말한다.

## ORM

* 객체와 관계형 DB를 Mapping해 준다.
* 객체와 테이블을 Mapping하기 때문에 SQL 쿼리를 직접 날리는 것이 아니라 마치 자바에서 라이브버리 사용하듯이 사용하면 된다.
* 객체와 관계형 데이터베이스와의 설정을 자동으로 해준다.
* 실제 데이터와 객체와의 개념적 일치하지 않는 부분을 자동으로 매핑해준다.
* 관계형 데이터베이스의 데이터를 객체형 데이터처럼 사용할 수 있다.
* Mybatis, iBatis, JPA, Hibernate
* 장점
  * 객체 지향적인 코드로 인해 더 직관적이고 비즈니스 로직에 집중할 수 있게 도와준다.
  * 선언문, 할당, 종료 같은 부수적인 코드가 줄어든다.
  * 재사용 및 유지 보수의 편리성이 증가한다.
  * DBMS에 대핸 종속성이 줄어든다.
  * SQL의 절차적이고 순차적인 접근이 아닌 객체 지향적인 접근으로 인해 생산성이 증가한다.
* 단점
  * 모든 기능을 ORM으로만 작성하기에는 쿼리가 복잡해지면 쓰기 어렵다.
  * 많은 수의 레코드를 잦은 빈도로 벌크 수행
  * 완벽한 ORM으로만 서비스를 구현하기가 어렵다.
  * 프로시저가 많은 시스템에선 ORM의 객체 지향적인 장점을 활용하기 어렵다.

## 웹 어플리케이션 동작 원리

1. 웹 어플리케이션 실행되면 Tomcat(WAS)에 의해 web.xml이 loading된다.
2. web.xml에 등록되어 있는 ContextLoaderListener(Java Class)가 생성된다. ContextLoaderListener 클래스는 ServletContextListener 인터페이스를 구현하고 있으며, ApplicationContext를 생성하는 역할을 수행한다.
3. 생성된 ContextLoaderListener는 root-context.xml을 loading한다.
4. root-context.xml에 등록되어 있는 Spring Container가 구동된다. 이 때 개발자가 작성한 비즈니스 로직에 대한 부분과 DAO, VO 객체들이 생성된다.
5. 클라이언트로부터 웹 어플리케이션으로 요청이 온다.
6. DispatcherServlet(Servlet)이 생성된다. DispatcherServlet은 FrontController의 역할을 수행한다. 클라이언트로부터 요청 온 메시지를 분석하여 알맞은 PageController에게 전달하고 응답을 받아 요청에 따른 응답을 어떻게 할 지 결정만 한다. 실질적인 작업은 PageController에서 이루어진다. 이러한 클래스들을 HandlerMapping, ViewResolver 클래스라고 한다.
7. DispatcherServlet은 servlet-context.xml을 loading한다.
8. 두번째 Spring Container가 구동되며 응답에 맞는 PageController 들이 동작한다. 이 때 첫번째 Spring Container가 구동되면서 생성된 DAO, VO, ServiceImpl 클래스들과 협업하여 알맞은 작업을 처리하게 된다.

## 주소창에 주소를 입력 했을 경우 동작

1. 브라우저는 DNS 서버를 통해 서버의 ip를 찾는다.
2. 브라우저는 서버에서 메시지를 전송하고 브라우저는 서버와 tcp/ip 연결을 하게 된다.
3. 서버는 브라우저의 요청을 승인하고 http 200을 전송한다. 이후 서버는 브라우저에게 패킷을 전송
4. 브라우저는 패킷을 조립해 사용자 ui을 화면에 그린다.

## 자바8

* 새로운 기능
  1. 람다 표현식
     * 동작과 데이터를 모두 동적으로 설정하는 것이 가능하다.
     * 메소드 참조가 가능하다.
  2. 스트림 API
     * 배열이나 리스트, 맵으로 대표되는 컬랙션을 스트림으로 다룰 수 있게 되었다.
  3. 인터페이스 개선
     * 인터페이스에서 static 메소드를 정의하는 것이 가능하다.
     * default 지시자를 이용해 기본 메소드의 정의가 가능하게 되어 인터페이스를 구현하는 기존 코드의 변경없이 새 메소드의 추가가 가능하다.
  4. Optional
     * 값을 Optional<T>로 캡슐화하여 NPE를 막는다.

## AOP(Aspect Oriented Programming)

* 모듈화의 핵심 단위는 관점(Aspect)이다.
* Aspect : 여러 클래스에 걸친 관심사의 모듈화이다.
* @Aspect 어노테이션이 붙은 정규 클래스(@AspectJ 방식)을 사용해서 관점을 구현했다.
* 로직 주입
* 프록시 패턴과 유사

## AOP 주요 용어

* Aspcet : 공통 기능, 여러 객체에 공통으로 적용되는 기능, 스프링은 프록시를 이용해서 메소드 호출 시점에 Aspect를 적용함
* Advice : 언제 공통 관심 기능을 핵심 로직에 적용할 지를 정의함, 메소드를 호출할 시점(언제) 과 트랜잭션 시작(공통 기능) 기능을 적용한다는 걱을 정의하고 있다.
  * Before : 대상 객체의 메소드 후출 전에 공통 기능을 실행하는 데 사용됨
  * After Returning : 대상 객체의 메소드가 예외 발생 없이 실행된 후에 공통 기능을 실행하는 데 사용됨
  * After Throwing : 대상 객체의 메소드를 실행하는 도중 예외가 발생한 경우에 공통 기능을 실행하는 데 사용됨
  * After : 대생 객체의 메소드를 실행후 무조건 공통 기능이 실행됨
  * Around : 대상 객체의 메소드 실행 전, 후 또는 예외 발생 시점에 공통 기능을 실행하는데 사용됨
* Joinpoint : Advice를 적용 가능한 지점을 정의함, 메소드 호출, 필드 값 변경 등이 Joinpoint에 해당함, 스프링은 프록시를 이용해 AOP를 구현허기 때문에 메소드 호출에 대한 Joinpoint만 지원함
* Pointcut : Joinpoint의 부분집합, 실제로 Advice가 적용되는 Joinpoint를 나타냄. 스프링에서는 정규 표현식이나 AspectJ의 문법을 이용하여 Pointcut을 정의할 수 있다.
* Weaving : Advice를 핵심 로직에 적용하는 것
* 스프링 AOP는 자바로만 구현되었고 여기에는 특별한 컴파일 과정이 필요없다.
* 스프링 AOP는 클래스 로더 계층을 제어할 필요가 없으므로 서블릿 컨테이너나 어플리케이션 서버에서 사용하기에 적합하다.
* 현재 스프링 AOP는 메소드 실행 조인 포인트만 지원한다.(스프링 빈의 메소드를 실행하는 어드바이스)

## Dependecy Injection(DI)

* 인스턴스를 자신이 아닌 IOC 컨테이너에서 생성 후 주입한다.
* 기능이 변결 될 때 마다 코드를 변경하는 것은 비용이 많이 들게 되므로 가급적 코드의 변화가 적어지도록 프로그램을 작성하기 위해 탄생
* 모듈 간 결합도를 낮춰서 유연한 변경을 가능하도록 한다.
* 불필요한 의존 관계를 없개거나 줄일 수 있다.
* 각 객체를 bean 컨테이너로 관리한다.
* IOC를 구현하는 한 가지 방법이 DI이다.

## Inversion of Control(IOC)

* 프로그램의 제어 흐름 구조가 바뀌는 것이다.
* 제어권이 스프링 컨테이너로 넘어간다.
* 제어권이 컨테이너로 넘어감으로써 DI, AOP가 가능하다.
* 인스턴스의 생성부터 소멸까지의 객체 생명주기를 스프링 컨테이너가 관리한다.
* 스프링에서 객체가 만들어지는 순서
  1. 객체 생성
  2. 의존성 객체 주입(스스로 만드는 것이 아니라 제어권을 가진 스프링에게 위임하여 스프링이 만들어 놓은 객체를 주입한다.)
  3. 의존성 객체 메소드 호출

## DB Index

* RDBMS에서 검색 속도를 높이기 위해 사용하는 기술
* 색인
* 해당 테이블의 컬럼을 색인화(따로 파일로 저장)하여 검색시, 테이블의 레코드를 full scan 하는것이 아니라 색인화 되어있는 index 파일을 검색하여 검색 속도를 빠르게 한다.
* B+ 트리로 저장된다.
* index로 설정한 컬럼 값이 변경되거나 추가되면, index 역시 변경된다. 따라서 적절하게 index를 설정해야 한다.
* 데이터의 삭제, 삽입이 빈번한 경우 index의 성능이 떨어진다. 매번 B+트리를 수정해야 하기 때문이다.
* index가 데이터베이스 공간을 차지하기 때문에 추가적인 공간이 필요하다.(10% 만큼의 추가적인 공간이 필요하다.)
* index를 생성하는데 시간이 많이 소요될 수 있다.
* index의 목적 : RDBMS의 검색 속도를 높이는데 있다.
* SELECT 쿼리의 WHERE 절이나 JOIN 예약어를 사용했을 때만 인덱스가 사용되며 SELECT 쿼리의 검색 속도를 빠르게 하는게 목적이다.
* 따라서 WHERE 절에서 사용되는 컬럼을 index로 만드는 것이 좋다.
* 데이터의 중복도가 높은 열은 index로 만들어도 효용가치가 없다.
* 외래키가 사용되는 열에는 인덱스를 생성해 주는 것이 좋다.
* INSERT/UPDATE/DELETE가 얼마나 자주 일어나는지를 고려해서 index를 설정해야 한다.
* 사용하지 않는 index는 제거하는 것이 좋다.

## MySql 엔진

* InnoDB : 기본값 스토리지 엔진
  * 트랜잭션 세잎, 커밋과 롤백, 데이터 복구 기능을 제공한다
  * row-level locking을 제공한다.
  * 데이터를 clusterd index에 저장하여 PK 기반의 query의 I/O 비용을 줄인다.
  * FK 제약을 제공하여 데이터 무결성을 보장한다.
* MyISAM 
  * 트랜잭션을 지원하지 않고, 테이블 단위의 locking을 제공한다.
  * 멀티 쓰레드 환경에서 성능이 저하 될 수 잇다.
  * 특정 세션이 테이블을 변경하는 동안 테이블 단위로 락이 잡힌다.
* Archive
  * 로그 수집에 적합한 엔진
  * 데이터가 메모리 상에서 압축되고 압축된 상태로 디스크에 저장된다.
  * row-level locking이 가능하다.
  * 한번 INSERT 된 데이터는 UPDATE/DELETE를 사용할 수 없다.
  * 인덱스를 지원하지 않는다.
  * 거의 가오하지 않을 원시 로그 데이터를 관리하는데 효율적이고, 테이블 파티셔닝도 지원한다.
  * 트랜잭션은 지원하지 않는다.

## OSI 7계층

1. 물리 계층(Physical)

   * 네트워크 하드웨어 전송 기술을 이룬다.
   * 실제 장치들을 연결하기 위해 필요한 전기적, 물리적 세부 사항들을 정의한다.
   * 물리적 매체를 통해 비트(Bit) 흐름을 전송한다.
   * 허브, 리피터

2.  데이터 링크 계층(Data Link)

   * Point to Point 간 신뢰성있는 전송을 보장하기 위한 계층
   * 오류 제어와 흐름 제어가 필요하다.
   * 오류없이 한 장치에서 다른 장치로 프레임(Frame, 비트의 모음)을 전달하는 역할
   * 3계층에서 정보를 받아 주소와 제어 정보를 Header와 Tail에 추가
   * MAC, PPP
   * 브릿지, 스위치

3. 네트워크 계층(Network)

   * 여러 개의 노드를 거칠 때 마다 경로를 찾아주는 역할을 하는 계층
   * 다중 네트워크 링크에서 패킷(Packet)을 발신지로부터 목적지로 전달할 책임을 가진다.
   * packets
   * IP, ICMP, IGMP
   * 라우터

4. 전송 계층(Transport)

   * End to End의 사용자들이 신뢰성있는 데이터를 주고 받을 수 있도록 해 주어, 상위 계층들이 데이터 전달의 유효성이나 효율성을 생각하지 않도록 해 준다.

   * 전체 메시지를 발신지 대 목적지(종단 대 종단)간 제어와 에러를 관리한다.

   * 패킷들의 전송이 유효한지 확인하고 실패한 패킷은 다시 보내는 등 신뢰성있는 통신을 보장하며, 머릿말에 세그먼트(Segment)가 포함된다.

   * TCP, UDP, ARP

   * 게이트 웨이

5. 세션 계층(Session)

   * 통신 세션을 구성하는 계층으로 포트(port) 연결이라고도 할 수 있다.
   * 통신 장치 간의 상호작용을 설정하고 유지하며 동기화한다.
   * 사용자간의 포트연결(세션)이 유효한지 확인하고 설정한다.
   * SSH, TLS
   * 응용간의 질서 제어

6. 표현 계층(Presentation)

   * 운영체계의 한 부분으로 입력 또는 출력되는 데이터를 하나의 표현 형태로 변환한다.
   * 필요한 번역을 수행하여 두 장치가 일관되게 전송 데이터를 서로 이해할 수 있도록 한다.
   * 압축
   * JPEG, MPEG

7. 응용 계층(Application)

   * 사용자가 네트워크에 접근할 수 있도록 해 주는 계층이다.
   * 사용자 인터페이스, 전자 우편, 데이터베이스 관리 등 서비스를 제공한다.
   * DHCP, DNS, FTP, HTTP, TELNET

## Object Pool

* 객체를 필요로 할 때 풀에 요청을 하고, 반환하는 일련의 작업을 수행하는 패턴
* 많은 수의 인스턴스를 생성할 때, 혹은 무거운 오브젝트를 매번 인스턴스화 할 때 성능 향상을 가져오기도 한다.
* 데이터 베이스에 접속하는 객체를 만들 때 매번 새로 생성하는 것 보단, 미리 생성된 풀에서 객체를 반환받아오는 것이 더 효율적이다.
* 오브젝트 불은 객체를 관리하는 그룹과 같다.
* pool이라는 곳에 객체를 생성하고 반환하는 행위 등이 이루어진다.

## Tomcat

* 아파치 소프트웨어 재단에서 개발한 서블릿 컨테이너 / 웹 컨테이너만 있는 WAS
* 웹 서버와 연동하여 실행할 수 있는 자바 환경을 제공하여 JSP와 자바 서블릿이 실행할 수 있는 환경을 제공한다.
* HTTP 서버도 자체 내장하기도 한다.
* 서블릿이나 JSP를 실행하기 위한 서블릿 컨테이너를 제공하며, 상용 WAS에서도 서블릿 컨테이너로 사용하는 경우가 많다.
* 아파치 웹 서버와 연동 모듈을 사용하여 안정적인 시스템을 구축한다.

## WAS(Web Application Server)

* 인터넷 상에서 HTTP를 통해 사용자 컴퓨터나 장치에 애플리케이션을 수행해 주는 미들웨어
* WAS는 동적 서버 컨텐츠를 수행하는 것으로 일반적인 웹 서버와 구별이 되며, 주로 DB 서버와 같이 수행이 된다.
* 대부분 자바 기반이다.
* 일반적으로 Web Server의 기능을 내제하고 있어 Web Server가 없어도 서비스가 가능하다.
* 프로그램 실행 환경과 데이터베이스 접속 기능을 제공한다.
* 여러 개의 트랜잭션을 관리한다.
* 업무를 처리하는 비즈니스 로직을 수행한다.

## WAS 생명주기

1. Web Server로 부터 요청이 들어오면 제일 먼저 컨테이너가 이를 알맞게 처리한다.
2. 컨테이너는 web.xml를 참조하여 해당 서블릿에 대한 스레드를 생성하고 HttpServeltRequest 및 HttpServletResponse 객체를 생성하여 전달한다.
3. 다음으로 컨테이너는 서블릿을 호출한다.(service())
4. 호출된 서블릿의 작업을 담당하게 된 스레드(미리 생성된 스레드)는 요청에 따라 doPost(), 또는 doGet()을 호출한다.
5. 호출된 doPost(), doGet() 메소드는 생성된 동적 페이지를 Response 객체에 실어서 컨테이너에 전달한다.
6. 컨테이너는 전달받은 Response 객체를 HttpResponse 형태로 전환하여 웹 서버에 전달하고 생성되었던 스레드를 종료하고 HttpServletRequest 및 HttpServletResponse 객체를 소멸시킨다.

## 접근 제어 지시자

* 나머지 생략
* default : 클래스 내부와 동일 패키지에서만 접근을 허용한다.

## 페이징(Paging) 기법

* 가상 메모리 사용, 외부 단편화 해결, 내부 단편화 존재
* 보조 기억 장치를 이용한 가상 메모리를 같은 크기의 블록으로 나눈 것을 페이지라고 정의
* RAM을 페이지와 같은 크기로 나눈 것을 프레임이라고 정의
* 사용하지 않는 프레임을 페이지에 옮기고, 필요한 메모리를 페이지 단위로 프레임에 옮기는 기법
* 페이지와 프레임을 대응시키기 위해 page mapping 과정이 필요해서 paging table을 만든다.
* 페이징 기법을 사용하면 연속적이지 않은 공간도 활용할 수 잇기 때문에 외부 단편화 문제를 해결할 수 있다.
* 페이지 단위에 알맞게 꽉 채워 쓰는 것이 아니므로 내부 단편화 문제는 여전히 존재
* 페이지 단위를 작게하면 내부 단편화 문제도 해결할 수 있겠지만 대신 page mapping 과정이 많아지므로 오히려 효율이 떨어질 수 있다.

## 세그먼트(Segmentation) 기법

* 가상 메모리 사용, 내부 단편화 해결, 외부 단편화 존재
* 가상 메모리를 서로 크기가 다른 논리적 단위인 세그먼트로 분할해서 메모리를 할당하여 실제 메모리 주소로 변환하게 된다.
* 각 세그먼트는 연속적인 공간에 저장되어 있다.
* 세그먼트들의 크기가 다르기 때문에 미리 분할해 둘 수 없고, 메모리에 적재될 때 빈 공간을 찾아 할당하는 기법이다.
* Mapping을 위해 세그먼트 테이블이 필요하다.
* 프로세스가 필요한 메모리 만큼 할당해주기 때문에 내부 단편화는 일어나지 않으나 여전히 프로세스가 메모리를 해제할 때 발생하는 외부 단편화 문제는 여전히 존재한다.

## 페이징과 세그멘테이션

* 세그멘테이션은 우리가 필요한 만큼 분할해서 메모리를 관리
* 페이징은 일정한 크기로 분할해서 메모리를 관리
* 세그멘테이션은 케익, 페이징은 잘려있는 식빵

## 스케쥴링

* 사용중인 프로세스에서 자원을 빼앗을 수 있는지의 여부에 따라 선점, 비선점 스케줄링
* 선점(Preemptive)
  * RR, SRT, MFQ
  * 하나의 프로세스가 CPU를 점유하고 있을 때 다른 프로세스가 프로세서를 빼앗 을 수 있는 방법
  * 프로세스의 우선 순위가 높은 프로세스가 CPU를 먼저 차지하기가 용이하기 때문에 실시간 시분할 시스템에서 사용한다.
  * 우선 순위가 높은 프로세스가 먼저 수행되어야 할 때 유용하다.
  * 빠른 응답 시간을 요구하는 프로세스가 먼저 수행되어야 할 때 유용하다.
  * 빠른 응답 시간을 요구하는 대화식 시분할 시스템이나 처리 시간이 제한되어 있는 실시간 시스템에 유용하다.
  * 많은 오버헤드를 초래한다.
* 비 선점(Non-Preemptive)
  * SJF, FIFO, HRN
  * 프로세스에게 이미 할당된 CPU를 강제로 빼앗을 수 없고, 그 프로세스의 사용이 끝난 후에 스케줄링을 하여야 하는 방법
  * 모든 프로세스들에 대한 요구를 공정히 처리한다.
  * 응답 시간의 예측이 용이하다.
  * 짧은 작업이 긴 작업을 기다리는 경우가 종종 발생한다.

## Mutex

* 상호 배제라고도 한다.
* 임계 영역에 무조건 접근 하지 못하도록 lock을 건다.
* 단 하나만 접근이 가능하다.
* 끝나면 un-lock 된다.
* 스레드의 순서를 보장하지 못한다.
* 공유된 자원의 데이터를 여러 스레드가 접근하는 것을 막는 것

## Semaphore

* 리소스의 상태를 나타내는 간단한 카운터
* 스레드의 실행 순서, 임계 영역에 접근 가능한 스레드를 지정할 수 있다.
* 카운트 값이 0이면 진입이 가능하고, 이상이면 진입이 불가능하다.
* 공유된 자원의 데이터를 여러 프로세스가 접근하는 것을 막아준다.

## 뮤텍스와 세마포어

* 세마포어는 뮤텍스가 될 수 있지만, 뮤텍스는 세마포어가 될 수 없다.
* 세마포어는 소유할 수 없는 반면, 뮤텍스는 소유가 가능하며 소유주가 이에 대한 책임을 지닌다.
* 뮤텍스의 경우 뮤텍스를 소유하고 있는 스레드가 이 뮤텍스를 해제할 수 있다. 하미잠 세마포어의 경우 세마포어를 소유하고 있지 않은 스레드도 세마포어를 해제할 수 있다.
* 세마포어는 시스템 범위에 걸쳐있고 파일 시스템상의 파일 형태로 존재한다. 반면 뮤텍스는 프로세스 범위를 가지며 프로세스가 종료될 때 자동으로 clean up 된다.
* 뮤텍스는 동기화 대상이 오직 하나뿐일 때, 세마포어는 동기화 대상이 하나 이상일 때 사용한다.

## 옵저버 패턴

* 한 객체의 상태가 바뀔 경우 다른 객체들에게 변경됐다고 알려주는 경우 사용
* 자바의 Observable 클래스와 Observer 인터페이스
* 안드로이드의 버튼 이벤트 등에서 쓰인다.

## 템플릿 메소드 패턴

* 알고리즘의 뼈대를 맞추는 것이다.
* 전체적인 레이아웃을 통일 시키지만 상속받은 클래스로 하여금 어느 정도 유연성을 주도록하는 디자인패턴
* 사우이 클래스에세 처리의 흐름을 제어하며, 하위 클래스에서 처리의 내용을 구체화한다.
* 여러 클래스에서 공통되는 사항은 상위 추상 클래스에서 구현하고 각각의 상세 부분은 하위 클래스에서 구현한다.
* 코드의 중복을 줄이고 리팩토링에 유리한 페턴이다.
* 안드로이드 onCreate

## 팩토리 패턴

* 객체를 생성하기 위한 인터페이스를 정의하는데, 어떤 클래스의 인스턴스를 만들지는 서브 클래스에서 결정하게 만든다.
* 클래스의 인스턴스를 만드는 일을 서브클래스에게 맡기는 것

## DDD(Domain Driven Design, 도메인 주도 설계)

* 모델과 핵심 설계는 상호 영향을 주고 받으며 구체화된다.
* 모델은 모든 팀 구성원들이 사용하는 언어의 근간을 이룬다.
* 모델은 불순물을 걸러낸 핵심 지식만을 포함한다.
* 도메인 그 자체와 도메인 로직에 초점을 맞춘다.
* 보편적인 언어의 사용 : 도메인 전문가와 개발자 간 커뮤니케이션 문제를 없애고 상호가 이해할 수 있고 모든 문서와 코드에 이르기까지 동일한 표현과 단어로 구성된 단일화된 언어체계를 구축해 나가는 과정
* 소프트웨어 엔티티와 도메인 컨트롤를 가능한 가장 가까이 일치시킨다. 도메인 모델부터 코드까지 항상 함께 움직이는 구조의 모델을 지향한다.

## Hash

* hash Function : 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수
* 해시 함수에 의해 얻어지는 값을 해시값, 해시코드, 해시
* 해쉬는 내부적으로 배열을 사용하여 데이터를 저장하기 때문에 빠른 검색속도를 가진다.

## Hash Map

* 내부적으로 Entry<K,V>[] entry의 array로 되어 있다.
* 해당 array에 index는 내부 해쉬 함수를 통해 계산된다.
* 내부 해시값에 따라서 키 순서가 정해지므로 특정 규칙없이 출력된다.

## Tree Map

* 내부적으로 RedBlack Tree로 저장된다.
* 키값에 대한 Compartor 구현으로 정렬 순서를 바꿀 수 있다.
* 키값이 정렬된다. 트리에 저장되므로 키값은 일정한 기준으로 정렬된 상태로 출력된다.

## LinkedHash Map

* LinkedList 로 저장된다.
* 키값은 입력 순서대로 출력되어서 나온다.

## Hash Table

* 데이터가 저장될 자리가 데이터 해시 값에 의해 결정되는 자료구조
* 해시 테이블의 성능은 공간을 팔아 얻어낸 것이다.
* 저장할 데이터의 값으로 저장할 위치를 계산할 수 있다.
* 평균 상수 시간에 삽입, 삭제, 검색이 가능하다.
* 매우 빠르게 자료를 저장 / 검색 해야 하는 경우에 유용하다.
* 충돌 해결 방법
  * chaning : 저장할 데이터를 링크드 리스트에 저장
  * Linear Probing : 그 다음 칸에 저장
  * Quadratic Probing : 그 다음 칸에 저장할 때, 제곲칸에 저장
  * Double Hashing : 건너뛰는 폭이 매번 다르게

## TCP

* 연결 지향형 프로토콜
* 데이터의 경계가 없다
* 전화(받았는지 못받았는지 확인이 가능하다.)
* UDP에 비해 전송 속도가 느리다.
* 서버 소켓과 클라이언트 소켓의 구분이 있다.
* 전송 순서대로 데이터가 송신되고 수신된다.
* 중간에 데이터가 소멸되지 않는다.
* 1대1 연결 구조

## UDP

* 비 연결 지향형 프로토콜
* 데이터의 경계가 있다.
* 우편(받았는지 못받았는지 확인이 불가능하다.)
* TCP에 비해 전송 속도가 빠르다.
* 서버 소켓과 클라이언트 소켓의 구분이 없다. 1개만 있으면 된다.
* 전송 순서가 상관없다.
* 데이터 손실 및 파손의 우려가 있다.
* 한번에 보낼 수 있는 데이터의 크기가 제한된다.

## 교착 상태(DeadLock)

* 두 개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태를 가리킨다.
* 교착 상태의 조건
  1. 상호 배제
  2. 점유 대기
  3. 비 선점
  4. 순환 대기
* 교착 상태의 관리
  1. 예방 - 교착 상태의 조건 제거
  2. 회피 - 자원 할당 그래프 알고리즘, 은행원 알고리즘
  3. 발견
  4. 무시

## 경쟁 상태(Race Condition)

* 공유 자원에 대해 여러 개의 프로세스가 동시에 접근을 시도할 때 접근의 타이밍이나 순서 등이 결과값에 영향을 줄 수 있는 상태를 말한다.
* 해결방법 : 세마포어

## HTTP 2

* Http 1에서는 앞의 요청의 응답을 받아야 다음 요청이 처리될 수 있다.
* Http 1에서는 Request를 날릴 때 마다 새로 Connection을 생성했다.
* Http 1.1에서는 지속 커넥션(Persistent Connection)이라는 개념과 Http 파이프라이닝(Pipelining)이라는 개념이 들어갔다. 커넥션을 재사용 할 수 있고, 서버에 여러개의 Request를 날릴 수도 있게 되었다. 그러나 Request를 날린 순서대로 Response를 받을 수 있다는 문제점이 있었다. 블록킹이 발생하면 뒤의 요청이 블록킹된다.
* Http 1.1에서는 1 Request당 한 개의 Resourece를 받아올 수 있었다.(한 커넥션에서 한번에 하나의 Response를 받을 수 있다.)
* Http 1.1에서는 플레인 텍스트로 구성되어 있었다.
* Http 2는 Multiplexing 개념이 도입되었다.
* 하나의 Request당 동시에 여러 리소스를 받아올 수 있게 되었다.
* 데이터를 전송할 때 바이너리로 인코딩하여 전송한다.
* Frame과 Stream이라는 개념이 추가되었다.
* Stream : 클라이언트와 서버 사이에 맺어진 연결을 통해 양방향으로 데이터를 주고 받는 한개 이상의 메시지를 의미

## HTTPS

* HTTP의 보안이 강화된 버전
* S는 Over Secure Socket Layer의 약자
* 소켓 통신(TCP)에서 일반 텍스트 대신에 SSL이나 TLS 프로토콜을 통해 세션 데이터를 암호화한다.
* 데이터의 적절한 보호를 보장한다.
* 통신이 느려진다.(클라이언트 요청시 SSL에 필요한 통신이 추가된다.)
* 암호화 복호화 계산을 하기 때문에 서버나 클라이언트의 리소스를 추가적으로 소비한다.
* 증명서를 구입해야 한다.

## CORS

## Spring MVC 동작 과정

## 3 Way HandShake

## 4 Way HandShake

## Java Exception

## OAuth

## Spring에 사용된 디자인 패턴

* 프록시 패턴 - AOP
* 팩토리 패턴 - beanFactory
* 싱글톤 패턴 - Application Context

## Replication(리플리케이션)

* 두 개 이상의 DMBS 시스템을 Master/Slave로 나눠서 동일한 데이터를 저장하는 방식
* Master에는 데이터의 수정 사항을 반영만 하고 Replication을 하여 Slave에 실제 데이터를 복사한다.
* INSERT/UPDATE/DELETE는 Master가 담당하고 SELECT는 Salve가 담당해서 성능 향상 효과를 얻을 수 있다.
* 로그 기반 복제
  * Statement Based : SQL 문장을 복사하여 진행
  * Row Based : SQL에 따라 변경된 Row 라인만 기록하는 방식
  * Mixed : 기본적으로 Statement Based로 진행하면서 필요에 따라 Row Based를 사용한다.

## Sharding(샤딩)

* 수평 파티셔닝과 동일하다.
* 대용량의 데이터를 처리하기 위해 테이블을 수평 분할하여 데이터를 분산 저장하고 처리하는 것
* 같은 타입의 데이터를 다수의 데이터베이스에 쪼개서 저장하는 것
* 샤딩 알고리즘이 매우 쉽게 일반화가 가능하기에 애플리케이션 레벨이나 데이터베이스 레벨에서 구현이 가능함

## Partitioning(파티셔닝)

* 큰 테이블이나 인덱스를 관리하기 쉬운 단위로 분리하는 방법을 의미한다.
* 물리적인 파티셔닝으로 인해 전체 데이터의 훼손 가능성이 줄어들고 데이터 가용성이 향상된다.
* 큰 테이블들을 제거하여 관리를 쉽게 해준다.
* 특정 DML과 쿼리의 성능을 향상시킨다. 주로 대용량 Data Write 환경에서 효율적이다.
* 많은 insert가 있는 OLTP 시스템에서 insert 작업들을 분리된 파티션들로 분산시켜 경합을 줄인다.
* 테이블간의 Join에 대한 비용이 증가한다.
* 테이블과 인덱스를 별로 파티션 할 수는 없다. 테이블과 인덱스를 같이 파티셔닝하여야 한다.

## Load Balancing(로드 밸런싱)

* 하나의 인터넷 서비스가 발생하는 트래픽이 많을 때 여러 대의 서버가 분산처리하여 서버의 로드율 증가, 부하량, 속도 저하등을 고려하여 적절히 분산처리하여 해결해준다.
* 네트워크 상단에 L4 스위치 가상 서버가 존재하여 서버로 들어오는 패킷을 리얼 서버로 균일하게 트래픽을 분산시킨다.
* 만약 리얼 서버 중 정상적으로 작동하지 않는 경우가 발생하면 이를 감지하여 정상적으로 작동하는 서버로 부하 분산시킵니다.
* 고가의 서버로 확장하지 않고 저렴한 비용으로 다수의 서버를 증설하여 경제적으로 비용절감 할 수 있다.
* 대량의 트래픽으로 1대의 서버로 집중적인 부하율이 높아지면 L4 스위치가 이를 감지하여 합리적으로 부하분산 처리를 할 수가 있다.
* 1대의 서버가 장애가 발생하여도 서비스 중단 없이 다른 서버로 적절히 자동으로 분배하여 서비스가 계속 운용 가능하게 할 수 있다.
* 서버 확장시 서비스 중단 없이 서버 증설이 가능하다.

## 클러스터링

* 복수개의 서버를 묶는 것이다.
* 일종의 분산 처리 시스템
* 똑같은 구성의 서버군을 병렬로 연결한 상태를 말한다.
* 서버들 중에서 한대의 서버에 이상이 생긴다면 로드밸런서에서 그 서버의 분배를 제거함으로서 정상적인 서비스가 끊김없이 이루어 진다.
* 처리 용량을 높이고 신뢰성과 가용성을 높이는 게 클러스터링의 목적이다.

## Join 원리

* 평소 데이터는 하드디스크의 데이터 파일에 저장해 두었다가 필요한 시점에 메모리로 복사한다.

* 컬럼 100개를 가진 테이블이 하드디스크에 저장되어 있을 때 사용자가 그 중 1개의 칼럼에 SELECT를 수행할 경우 해당 컬럼 1개만 메모리로 복사하는 것이 아니라 일단 100개의 칼럼 모두를 메모리로 복사해 온다.

* 그래서 불필요한 I/O도 많고 메모리 사용량도 많이 생기기 때문에 정규화를 철저히 해서 부하를 최대한 줄여야 한다.

* Join 수행 작업 순서

  1. 사원 테이블과 부서 테이블을 메모리(데이터베이스 버퍼 캐시)로 복사해온다.

  2. 그후에 사원테이블에서 사원이름을 꺼내서 임시 작업공간으로 가져 간다.(인덱스 상황이나 다른 요소에 따라 작업순서가 변경될 수도 있다.)

  3. 그 후에 부서 테이블에서 해당부서명을 찾으러 가는데 그때 위 SQL의 3행에 있는 조건을 보고 해당 조건에 맞는 데이터를 찾아서 부서명을 가져온다.

  4. 한 행의 작업이 끝나면 다시 처음 테이블로 돌아가서 두 번째 행의 이름을 다시 PGA로 가져온다.

  5. 다시 부서 테이블에 가서 사원 테이블에서 가져온 두 번째 행의 부서번호와 동일한 부서번호를 가진 부서명을 꺼내온다.

* 위 과정을 사원 테이블의 데이터가 끝이 날 때 까지 작업이 반복된다.

## Heap

## Object Oriented Programming (객체 지향 프로그래밍)

* 프로그램을 수많은 객체라는 기본 단위로 나누고 이 객체들의 상호작용으로 프로그램을 서술하는 방식
* 객체를 데이터 묶음 뿐만 아니라 하나의 역할을 수행하는 메소드와 데이터의 묶음
* 큰 문제를 작게 쪼개는 것이 아니라, 먼저 작은 문제들을 해결할 수 있는 객체들을 만든 뒤, 이 객체들을 조합해서 큰 문제를 해결하는 상향식(Bottom up) 해결법 도입
* 캡슐화(Encapsulation)
  * 프로그램의 세부 구현을 외부로 드러나지 않도록 특정 모듈(클래스) 내부로 감추는 것이다.
  * 접근 제어 지시자를 통해 외부에서 접근을 제어 한다.
* 상속(Inheritance)
  * 자식 클래스가 부모 클래스의 특성과 기능을 그대로 물려받는 것을 말한다.
  * 오버라이딩을 통해 자식 클래스에서 상속받은 기능만을 재 정의해 사용이 가능하다.
* 다형성(Polymorphism)
  * 하나의 변수, 함수등이 상황에 따라 다른 의미로 해석될 수 있다
  * 오버로딩

## Array

* 특정 자료형들이 메모리 공간상에서 연속적으로 이루어져 있는 자료구조
* 데이터를 메모리상에 연속적으로 나열해두었다는 특성 때문에 데이터에 대한 접근이 엄청나게 빠르다.
* index 값을 통해 바로 원하는 공간에 가서 자료를 확인할 수 있기 때문에, 딱 한번의 접근만 필요하므로 O(1)의 시간 복잡도를 가진다.
* immutable이다.

## Linked List

* 여러개의 노드들이 연결된 형태의 자료구조
* 메모리 공간상에서 각 노드들이 연속적으로 이루어져 있지 않고 흩어져 있으며, 각각의 노드가 자신의 다음 노드의 위치를 알고 잇는 형태로 구현된다.
* 각 노들이 메모리 공간상의 어디에 위치하는지 각각의 노드들만 알고 있고, 사용자는 제일 첫 노드의 위치만 알고 있게 된다.
* O(N)의 시간 복잡도를 가진다.
* 노드를 추가하고 제거하는 과정을 통해 최대 노드의 수를 언제든지 변경할 수 있기 때문에 공간을 유동적으로 사용할 수 있다.
* 노드의 삽입,삭제도 배열에 비해 간단하다.

## Linked List(연결 리스트) VS Array(배열)

* 배열은 데이터의 접근은 빠르지만, 메모리 공간활용에 제약이 있으며, 데이터의 추가와 삭제가 비효율적이다.
* 연결 리스트는 데이터의 접근이 다소 느리지만, 메모리 공간 활용 및 데이터의 추가와 삭제가 효율적이다.

## Hystrix 생명 주기

1. HystrixCommand, HystrixObservableCommand 객체 생성
2. Command 실행
3. 캐시 상태 확인
4. 회로 상태 확인
5. 사용 가능한 Thread Pool / Semaphore가 있는지 확인
6. HystrixObservableCommand.construc() / HystrixCommand.run() 실행
7. Calculate Circuit Health 확인
8. Fallback 실행
9. 응답 반환

## Java Default

## 함수형 프로그래밍

* 순수 함수를 조합하고 공유 상태, 변경 가능한 데이터 및 부작용을 피하여 소프트웨어를 만드는 프로세스
* 명령형이 아닌 선언형

## Java Enum

* 열거 타입, 변수를 선언할 때 변수 타입으로 사용할 수 있다.
* IDE의 지원을 받을 수 있다.(자동 완성, 오타 검증, 텍스트 리팩토링)
* 허용 가능한 값들을 제한할 수 있다.
* 리팩토링시 변경 범위가 최소화된다. 내용의 추가가 필요하더라도, Enum 코드외에 수정할 필요가 없다.
* 완전한 기능을 갖춘 클래스이다.

## Java Annotation

* 자바 소스 코드에 추가하여 사용할 수 있는 메타데이터의 일종이다.
* @기호를 붙여서 사용한다.
* JDK 1.5 버전 이상에서 사용 가능하다.
* 클래스 파일에 임베디드되어 컴파일러에 의해 생성된 후 JVM에 포함되어 작동한다.

## Java Reflection

* 객체를 통해 클래스의 정보를 분석해 내는 프로그램 기법
* 자바는 동적으로 객체를 생성하는 기술이 없다. 그리고 동적으로 인스턴스를 생성하는 Reflection으로 그 역할을 대신하게 된다.
* Reflection은 구체적인 클래스 타입을 알지 못해도, 그 클래스의 메소드, 타입, 변수들을 접근할 수 있도록 해주는 자바 API이다.

## URI(Uniform Resource Identifier)

* 통합 자원 식별자
* 인터넷에 있는 자원을 나타내는 유일한 주소이다.
* 어떤 Resource의 위치를 의미한다.
* 유니크한 이름을 통해 상대적 경로를 가지고 구분할 수도 있다.

## URL (Uniform Resource Locator)

* 유일 자원 지시기
* 어떤 자원의 위치에 대한 절대경로값을 지닌 문자열

## Payload

* 전송되는 데이터를 뜻한다.
* 전송의 근본적인 목적이 되는 데이터의 일부분
* 그 데이터와 함께 전송되는 헤더와 메타데이터와 같은 데이터는 제외한다.
* Body에 담기는 data

## REST(Representational State Transfer)

* 리소스, 메소드, 메시지 3가지 요소로 구성된다.
* 리소스 지향 아키텍쳐 스타일이라는 정의 답게 모든 것을 리소스, 명사로 표현을 한다.
* 유니폼 인터페이스
  * HTTP 표준에만 따른다면 어떠한 기술이라던지 사용이 가능한 인터페이스 스타일이다.
* 무상태성(Stateless) : 상태 정보를 저장하지 않고 각 API 서버는 들어오는 요청만을 들어오는 메시지로만 처리하면 된다.
* 캐싱 가능(Cacheable)
* 계층화 : 클라이언트는 서버와 직접 통신하는지, 중간 서버를 통해 통신하는지 알 수 없다.

## Node

* non-blocking I/O와 단일 스레드 이벤트 루프 기반이다.
* 내장 HTTP 서버 라이브러리를 포함하고 있다.
* V8 엔진 위에서 동작하는 이벤트 처리 I/O 프레임워크다.

## IO

* input/output
* 입출력 방식 : stream
* 데이터 형식 : byte
* Synchronous
* Blocking
* 단방향 통신
* 접속하는 클라이언트 수가 적을 때, 순차적, 대용량

## NIO

* non-blocking I/O가 아니다.
* 입출력 방식 : channel
* 데이터 형식 : buffer
* Asynchronous, Synchronous
* Non-Blocking / Blocking
* 양방향 통신
* 접속하는 클라이언트 수가 많을때, 하나의 I/O가 오래 걸리지 않을 때

## Blocking

* 스레드가 작업이 종료 될 때 까지 대기한다.
* 호출된 함수가 자신의 작업을 모두 마칠 때 까디 호출한 함수에게 제어권을 넘겨주지 않고 대기하게 만든다.

## Non-Blocking

* 스레드가 작업이 종료될 때 까지 기다리지 않는다.
* 호출된 함수가 바로 리턴해서 호출한 함수에게 제어권을 넘겨주고, 호출한 함수가 다른 일을 할 수 있는 기회를 줄 수 있다.

## Blocking/NonBlocking

* 호출되는 함수가 바로 리턴하는지 안하는지가 관심사
* 호출된 함수가 바로 리턴해서 호출한 함수에게 제어권을 넘겨주고, 호출한 함수가 다른 일을 할 수 있는 기회를 줄 수 있으면 NonBlocking
* 호출된 함수가 자신의 작업을 모두 마칠 때까지 호출한 함수에게 제어권을 넘겨주지 않고 대기하게 만든다면 Blocking

## Synchronous

## Asynchronous

## Synchronous/Asynchronous

* 호출되는 함수의 작업 완료 여부를 누가 신경쓰냐가 관심사
* 호출되는 함수에게 callback을 전달해서 호출되는 함수의 작업이 완료되면 호출되는 함수가 전달받은 callback을 실행하고, 호출하는 함수는 작업 완료 여부를 신경쓰지 않으면 Asynchronous
* 호출하는 함수가 호출되는 함수의 작업 완료 후 반환을 기다리거나, 또는 호출되는 함수로부터 바로 리턴 받더라도 작업 완료 여부를 호출하는 함수 스스로 계속 확인하며 신경쓰면 Synchronous

## ACID

* 데이터베이스 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질을 가리키는 약어
* Atomicity : 원자성
* Consistency : 일관성
* Isolation : 고립성
* Durability : 지속성

## Java Exception

* Checked Exception
  * 반드시 예외를 처리해야 한다
  * 컴파일 단계에서 확인한다.
  * 예외 발생시 트랜잭션 처리를 Rollback 하지 않는다.
  * Exception의 상속받는 하위 클래스중 Runtime Exception을 제외한 모든 예외
    * IOException
    * SQLException
* UnChecked Exception
  * 명시적인 처리를 강제하지 않는다.
  * 실행단계에서 확인한다.
  * 예외 발생시 트랜잭션 처리를 Rollback 한다.
  * Runtime Exception 하위 예외
    * NullPointerException
    * IllegalArgumentException
    * IndexOutOfBoundException
    * SystemException

## Mybatis

* JDBC를 대체하는 Persistence Framework
* 개발자가 작성한 SQL 명령어와 자바 객체를 맵핑해 주는 기능 제공
* SQL 명령을 XML로 관리
* 기존 DAO 클래스에서 DB 실행을 위한 JDBC 코드를 XML로 분산한다.

## JIT Compile(Just In Time Comilation)

* 자바는 JIT 방식을 사용한다.
* 바이트 코드를 실행하기 직전에 기계어 코드로 컴파일 하는 방식이다.
* 바이트 코드를 해석해서 실행하는 것 보다(인터프리터) 기계어 코드로 변환해서 실행하는 것이 훨씬 더 빠르다.
* 실행할 때 마다 매번 다시 jit 컴파일을 해야 한다.
* 동적 최적화가 가능하다.
* 소스코드와 동일한 순서로 기계어 코드를 생성하지 않고, 좀 더 빠르고 효율적으로 실행될 수 있도록 실행순서를 재배치하고 조정하여 기계어 코드를 생성한다.
* 실행하는 시점에 실행 순서를 재배치하고 조정하여 기계어 코드를 생성한다.

