# 카카오IX 면접 준비

## 인터페이스

* 클래스들이 구현해야 하는 동작을 지정하는데 사용되는 추상형
* 규약, 규제
* 추상 클래스의 극단적인 경우
* 인터페이스도 상속이 가능하다.
* 클래스와 달리 다중 상속이 가능하다.
* 자바 8에서 인터페이스가 가질 수 있는것
  * 상수 필드(public static final) : 기존, 생략 가능
  * 추상 메소드(public abstract)  : 기존 ,생략 가능
  * 디폴트 메소드(public default) : 추가
    * 이전에 개발한 구현 클래스를 그대로 사용하지 않고 변경하지 않으면서, 새롭게 개발하는 클래스는 디폴트 메소드를 활용해 새로운 기능을 만들 수 있다.

## 다형성

* 하나의 메소드나 클래스가 상황에 따라 다양한 방법으로 동작하는 것을 의미한다.
* 오버로딩은 다형성의 가장 대표적인 예
* 다형성 조건
  * 공통의 부모
  * 공통의 메소드 재정의
  * 부모 타입의 변수로 호출

## 제네릭

* 다양한 타입의 객체들을 다루는 메소드나 컬렉션 클래스에 컴파일 시의 타입 체크를 해주는 기능이다.
* 클래스 내부에서 사용할 데이터 타입을 나중에 인스턴스를 생성할 때 확정하는 것을 제네릭이라 한다.
* 타입 안정성을 제공한다.
* 타입체크와 형변환을 생략할 수 있으므로 코드가 간결해진다.

## JVM

* 자바 애플리케이션을 클래스 로더를 통해 읽어 들려 자바 API와 함께 실행하는 것이다.
* 자바 바이트 코드를 실행할 수 있는 주체이다.
* 인터프리터나 JIT 컴파일 방식으로 다른 컴퓨터 위에서 자바 바이트 코드를 실행할 수 있도록 구현한다.
* 자바 바이트코드는 플랫폼에 독립적이다.
* 모든 JVM은 JVM 규격에 정의된 대로 자바 바이트 코드를 실행한다.
* 스택 기반이다.
* 대다수의 명령어가 스택 선두에서 피연산자를 택하고 결과는 다시 스택에 넣는다.
* 포인터를 지원하지만, C 처럼 주소 값을 임의로 조작이 가능한 포인터 연산은 불가능하다.
* GC를 사용한다.
* 메모리 관리가 가능하다.
* 

## GC

## Spring

* 스스로 발전하는 프레임워크
* 스프링 개발 철학 중 하나는 "항상 프레임워크 기반의 접근 방법을 사용하라"
* 스프링 기능의 대부분은 핵심 기능을 확장해서 발전시킨 결과물이다.
* 단순함과 유연성을 중요 가치로 생각한다.
* 정의 : 자바 엔터프라이즈 개발을 편하게 해주는 오픈소스 경량급 애플리케이션 프레임워크

## Spring Bean Life Cycle

## Spring Container

## Spring Data JPA

## Servlet

* 자바를 사용하여 웹 페이지를 동적으로 생성하는 서버측 프로그램
* 웹 서버의 성능을 향상하기 위해 사용되는 자바 클래스의 일종이다.
* JSP와 비슷한 점이 있지만, JSP는 html 문서 안에 자바 코드를 포함하고 있지만, 서블릿은 자바 코드안에 HTML을 포함하고 있다.
* 외부 요청마다 스레드로 응답하므로 가볍다.

## Dispatcher Servlet

* 해당 애플리케이션으로 들어오는 요청을 모두 핸들링해준다.
* Dispatcher Servlet을 이용한다는 것은 스프링에서 제공하는 @MVC를 이용하겠단 뜻
* HTTP 프로토콜을 통해 들어오는 모든 요청을 프레젠테이션 계층의 제일 앞에 둬서 중앙 집중식으로 처리해주는 프론트 컨트롤러(Front Controller)
* 공통 처리 작업을 Dispatcher Servlet이 처리한 수, 적절한 세부 컨트롤러로 작업을 위임해 준다.
* web.xml의 역할을 상당히 축소시켜주었다.

## Java Bean

* 원래는 비주얼 툴에서 조작 가능한 컴포넌트를 말한다.
* 간단히 빈이라고 부르기도 한다.
* 현재는 다음 두 가지 관계를 따라 만들어진 오브젝트를 가리킨다.
  * 디폴트 생성자 : 자바빈은 파라미터가 없는 디폴트 생성자를 갖고 있어야 한다. 툴이나 프레임워크에서 리플렉션을 이용해 오브젝트를 생성하기 때문에 필요하다.
  * 프로퍼티 : 자바빈이 노출하는 이름을 가진 속성을 프로퍼티라고 한다. 프로퍼티는 set으로 시작하는 수정자 메소드(setter)와 get으로 시작하는 접근자 메소드(getter)를 이용해 수정 또는 조회할 수 있다.

## DAO(Data Access Object)

* DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트를 말한다.

## ORM

* 객체와 관계형 DB를 Mapping해 준다.
* 객체와 테이블을 Mapping하기 때문에 SQL 쿼리를 직접 날리는 것이 아니라 마치 자바에서 라이브버리 사용하듯이 사용하면 된다.
* 객체와 관계형 데이터베이스와의 설정을 자동으로 해준다.
* 실제 데이터와 객체와의 개념적 일치하지 않는 부분을 자동으로 매핑해준다.
* 관계형 데이터베이스의 데이터를 객체형 데이터처럼 사용할 수 있다.
* Mybatis, iBatis, JPA, Hibernate
* 장점
  * 객체 지향적인 코드로 인해 더 직관적이고 비즈니스 로직에 집중할 수 있게 도와준다.
  * 선언문, 할당, 종료 같은 부수적인 코드가 줄어든다.
  * 재사용 및 유지 보수의 편리성이 증가한다.
  * DBMS에 대핸 종속성이 줄어든다.
  * SQL의 절차적이고 순차적인 접근이 아닌 객체 지향적인 접근으로 인해 생산성이 증가한다.
* 단점
  * 모든 기능을 ORM으로만 작성하기에는 쿼리가 복잡해지면 쓰기 어렵다.
  * 많은 수의 레코드를 잦은 빈도로 벌크 수행
  * 완벽한 ORM으로만 서비스를 구현하기가 어렵다.
  * 프로시저가 많은 시스템에선 ORM의 객체 지향적인 장점을 활용하기 어렵다.

## 주소창에 주소를 입력 했을 경우 동작

## 자바8

* 새로운 기능
  1. 람다 표현식
     * 동작과 데이터를 모두 동적으로 설정하는 것이 가능하다.
     * 메소드 참조가 가능하다.
  2. 스트림 API
     * 배열이나 리스트, 맵으로 대표되는 컬랙션을 스트림으로 다룰 수 있게 되었다.
  3. 인터페이스 개선
     * 인터페이스에서 static 메소드를 정의하는 것이 가능하다.
     * default 지시자를 이용해 기본 메소드의 정의가 가능하게 되어 인터페이스를 구현하는 기존 코드의 변경없이 새 메소드의 추가가 가능하다.
  4. Optional
     * 값을 Optional<T>로 캡슐화하여 NPE를 막는다.

## AOP

## DI

## IOC

## DB Index

* RDBMS에서 검색 속도를 높이기 위해 사용하는 기술
* 색인
* 해당 테이블의 컬럼을 색인화(따로 파일로 저장)하여 검색시, 테이블의 레코드를 full scan 하는것이 아니라 색인화 되어있는 index 파일을 검색하여 검색 속도를 빠르게 한다.
* B+ 트리로 저장된다.
* index로 설정한 컬럼 값이 변경되거나 추가되면, index 역시 변경된다. 따라서 적절하게 index를 설정해야 한다.
* 데이터의 삭제, 삽입이 빈번한 경우 index의 성능이 떨어진다. 매번 B+트리를 수정해야 하기 때문이다.
* index가 데이터베이스 공간을 차지하기 때문에 추가적인 공간이 필요하다.(10% 만큼의 추가적인 공간이 필요하다.)
* index를 생성하는데 시간이 많이 소요될 수 있다.
* index의 목적 : RDBMS의 검색 속도를 높이는데 있다.
* SELECT 쿼리의 WHERE 절이나 JOIN 예약어를 사용했을 때만 인덱스가 사용되며 SELECT 쿼리의 검색 속도를 빠르게 하는게 목적이다.
* 따라서 WHERE 절에서 사용되는 컬럼을 index로 만드는 것이 좋다.
* 데이터의 중복도가 높은 열은 index로 만들어도 효용가치가 없다.
* 외래키가 사용되는 열에는 인덱스를 생성해 주는 것이 좋다.
* INSERT/UPDATE/DELETE가 얼마나 자주 일어나는지를 고려해서 index를 설정해야 한다.
* 사용하지 않는 index는 제거하는 것이 좋다.

## MySql 엔진

* InnoDB : 기본값 스토리지 엔진
  * 트랜잭션 세잎, 커밋과 롤백, 데이터 복구 기능을 제공한다
  * row-level locking을 제공한다.
  * 데이터를 clusterd index에 저장하여 PK 기반의 query의 I/O 비용을 줄인다.
  * FK 제약을 제공하여 데이터 무결성을 보장한다.
* MyISAM 
  * 트랜잭션을 지원하지 않고, 테이블 단위의 locking을 제공한다.
  * 멀티 쓰레드 환경에서 성능이 저하 될 수 잇다.
  * 특정 세션이 테이블을 변경하는 동안 테이블 단위로 락이 잡힌다.
* Archive
  * 로그 수집에 적합한 엔진
  * 데이터가 메모리 상에서 압축되고 압축된 상태로 디스크에 저장된다.
  * row-level locking이 가능하다.
  * 한번 INSERT 된 데이터는 UPDATE/DELETE를 사용할 수 없다.
  * 인덱스를 지원하지 않는다.
  * 거의 가오하지 않을 원시 로그 데이터를 관리하는데 효율적이고, 테이블 파티셔닝도 지원한다.
  * 트랜잭션은 지원하지 않는다.

## OSI 7계층

1. 물리 계층(Physical)

   * 네트워크 하드웨어 전송 기술을 이룬다.
   * 실제 장치들을 연결하기 위해 필요한 전기적, 물리적 세부 사항들을 정의한다.
   * 물리적 매체를 통해 비트(Bit) 흐름을 전송한다.
   * 허브, 리피터

2.  데이터 링크 계층(Data Link)

   * Point to Point 간 신뢰성있는 전송을 보장하기 위한 계층
   * 오류 제어와 흐름 제어가 필요하다.
   * 오류없이 한 장치에서 다른 장치로 프레임(Frame, 비트의 모음)을 전달하는 역할
   * 3계층에서 정보를 받아 주소와 제어 정보를 Header와 Tail에 추가
   * MAC, PPP
   * 브릿지, 스위치

3. 네트워크 계층(Network)

   * 여러 개의 노드를 거칠 때 마다 경로를 찾아주는 역할을 하는 계층
   * 다중 네트워크 링크에서 패킷(Packet)을 발신지로부터 목적지로 전달할 책임을 가진다.
   * packets
   * IP, ICMP, IGMP
   * 라우터

4. 전송 계층(Transport)

   * End to End의 사용자들이 신뢰성있는 데이터를 주고 받을 수 있도록 해 주어, 상위 계층들이 데이터 전달의 유효성이나 효율성을 생각하지 않도록 해 준다.

   * 전체 메시지를 발신지 대 목적지(종단 대 종단)간 제어와 에러를 관리한다.

   * 패킷들의 전송이 유효한지 확인하고 실패한 패킷은 다시 보내는 등 신뢰성있는 통신을 보장하며, 머릿말에 세그먼트(Segment)가 포함된다.

   * TCP, UDP, ARP

   * 게이트 웨이

5. 세션 계층(Session)

   * 통신 세션을 구성하는 계층으로 포트(port) 연결이라고도 할 수 있다.
   * 통신 장치 간의 상호작용을 설정하고 유지하며 동기화한다.
   * 사용자간의 포트연결(세션)이 유효한지 확인하고 설정한다.
   * SSH, TLS
   * 응용간의 질서 제어

6. 표현 계층(Presentation)

   * 운영체계의 한 부분으로 입력 또는 출력되는 데이터를 하나의 표현 형태로 변환한다.
   * 필요한 번역을 수행하여 두 장치가 일관되게 전송 데이터를 서로 이해할 수 있도록 한다.
   * 압축
   * JPEG, MPEG

7. 응용 계층(Application)

   * 사용자가 네트워크에 접근할 수 있도록 해 주는 계층이다.
   * 사용자 인터페이스, 전자 우편, 데이터베이스 관리 등 서비스를 제공한다.
   * DHCP, DNS, FTP, HTTP, TELNET

## Object Pool

* 객체를 필요로 할 때 풀에 요청을 하고, 반환하는 일련의 작업을 수행하는 패턴
* 많은 수의 인스턴스를 생성할 때, 혹은 무거운 오브젝트를 매번 인스턴스화 할 때 성능 향상을 가져오기도 한다.
* 데이터 베이스에 접속하는 객체를 만들 때 매번 새로 생성하는 것 보단, 미리 생성된 풀에서 객체를 반환받아오는 것이 더 효율적이다.
* 오브젝트 불은 객체를 관리하는 그룹과 같다.
* pool이라는 곳에 객체를 생성하고 반환하는 행위 등이 이루어진다.

## Tomcat

* 아파치 소프트웨어 재단에서 개발한 서블릿 컨테이너 / 웹 컨테이너만 있는 WAS
* 웹 서버와 연동하여 실행할 수 있는 자바 환경을 제공하여 JSP와 자바 서블릿이 실행할 수 있는 환경을 제공한다.
* HTTP 서버도 자체 내장하기도 한다.
* 서블릿이나 JSP를 실행하기 위한 서블릿 컨테이너를 제공하며, 상용 WAS에서도 서블릿 컨테이너로 사용하는 경우가 많다.
* 아파치 웹 서버와 연동 모듈을 사용하여 안정적인 시스템을 구축한다.

## WAS(Web Application Server)

* 인터넷 상에서 HTTP를 통해 사용자 컴퓨터나 장치에 애플리케이션을 수행해 주는 미들웨어
* WAS는 동적 서버 컨텐츠를 수행하는 것으로 일반적인 웹 서버와 구별이 되며, 주로 DB 서버와 같이 수행이 된다.
* 대부분 자바 기반이다.
* 일반적으로 Web Server의 기능을 내제하고 있어 Web Server가 없어도 서비스가 가능하다.
* 프로그램 실행 환경과 데이터베이스 접속 기능을 제공한다.
* 여러 개의 트랜잭션을 관리한다.
* 업무를 처리하는 비즈니스 로직을 수행한다.

## WAS 생명주기

1. Web Server로 부터 요청이 들어오면 제일 먼저 컨테이너가 이를 알맞게 처리한다.
2. 컨테이너는 web.xml를 참조하여 해당 서블릿에 대한 스레드를 생성하고 HttpServeltRequest 및 HttpServletResponse 객체를 생성하여 전달한다.
3. 다음으로 컨테이너는 서블릿을 호출한다.(service())
4. 호출된 서블릿의 작업을 담당하게 된 스레드(미리 생성된 스레드)는 요청에 따라 doPost(), 또는 doGet()을 호출한다.
5. 호출된 doPost(), doGet() 메소드는 생성된 동적 페이지를 Response 객체에 실어서 컨테이너에 전달한다.
6. 컨테이너는 전달받은 Response 객체를 HttpResponse 형태로 전환하여 웹 서버에 전달하고 생성되었던 스레드를 종료하고 HttpServletRequest 및 HttpServletResponse 객체를 소멸시킨다.

## 접근 제어 지시자

* 나머지 생략
* default : 클래스 내부와 동일 패키지에서만 접근을 허용한다.

## 페이징(Paging) 기법

* 가상 메모리 사용, 외부 단편화 해결, 내부 단편화 존재
* 보조 기억 장치를 이용한 가상 메모리를 같은 크기의 블록으로 나눈 것을 페이지라고 정의
* RAM을 페이지와 같은 크기로 나눈 것을 프레임이라고 정의
* 사용하지 않는 프레임을 페이지에 옮기고, 필요한 메모리를 페이지 단위로 프레임에 옮기는 기법
* 페이지와 프레임을 대응시키기 위해 page mapping 과정이 필요해서 paging table을 만든다.
* 페이징 기법을 사용하면 연속적이지 않은 공간도 활용할 수 잇기 때문에 외부 단편화 문제를 해결할 수 있다.
* 페이지 단위에 알맞게 꽉 채워 쓰는 것이 아니므로 내부 단편화 문제는 여전히 존재
* 페이지 단위를 작게하면 내부 단편화 문제도 해결할 수 있겠지만 대신 page mapping 과정이 많아지므로 오히려 효율이 떨어질 수 있다.

## 세그먼트(Segmentation) 기법

* 가상 메모리 사용, 내부 단편화 해결, 외부 단편화 존재
* 가상 메모리를 서로 크기가 다른 논리적 단위인 세그먼트로 분할해서 메모리를 할당하여 실제 메모리 주소로 변환하게 된다.
* 각 세그먼트는 연속적인 공간에 저장되어 있다.
* 세그먼트들의 크기가 다르기 때문에 미리 분할해 둘 수 없고, 메모리에 적재될 때 빈 공간을 찾아 할당하는 기법이다.
* Mapping을 위해 세그먼트 테이블이 필요하다.
* 프로세스가 필요한 메모리 만큼 할당해주기 때문에 내부 단편화는 일어나지 않으나 여전히 프로세스가 메모리를 해제할 때 발생하는 외부 단편화 문제는 여전히 존재한다.

## 페이징과 세그멘테이션

* 세그멘테이션은 우리가 필요한 만큼 분할해서 메모리를 관리
* 페이징은 일정한 크기로 분할해서 메모리를 관리
* 세그멘테이션은 케익, 페이징은 잘려있는 식빵

## 스케쥴링

* 사용중인 프로세스에서 자원을 빼앗을 수 있는지의 여부에 따라 선점, 비선점 스케줄링
* 선점(Preemptive)
  * RR, SRT, MFQ
  * 하나의 프로세스가 CPU를 점유하고 있을 때 다른 프로세스가 프로세서를 빼앗 을 수 있는 방법
  * 프로세스의 우선 순위가 높은 프로세스가 CPU를 먼저 차지하기가 용이하기 때문에 실시간 시분할 시스템에서 사용한다.
  * 우선 순위가 높은 프로세스가 먼저 수행되어야 할 때 유용하다.
  * 빠른 응답 시간을 요구하는 프로세스가 먼저 수행되어야 할 때 유용하다.
  * 빠른 응답 시간을 요구하는 대화식 시분할 시스템이나 처리 시간이 제한되어 있는 실시간 시스템에 유용하다.
  * 많은 오버헤드를 초래한다.
* 비 선점(Non-Preemptive)
  * SJF, FIFO, HRN
  * 프로세스에게 이미 할당된 CPU를 강제로 빼앗을 수 없고, 그 프로세스의 사용이 끝난 후에 스케줄링을 하여야 하는 방법
  * 모든 프로세스들에 대한 요구를 공정히 처리한다.
  * 응답 시간의 예측이 용이하다.
  * 짧은 작업이 긴 작업을 기다리는 경우가 종종 발생한다.

## Mutex

* 상호 배제라고도 한다.
* 임계 영역에 무조건 접근 하지 못하도록 lock을 건다.
* 단 하나만 접근이 가능하다.
* 끝나면 un-lock 된다.
* 스레드의 순서를 보장하지 못한다.
* 공유된 자원의 데이터를 여러 스레드가 접근하는 것을 막는 것

## Semaphore

* 리소스의 상태를 나타내는 간단한 카운터
* 스레드의 실행 순서, 임계 영역에 접근 가능한 스레드를 지정할 수 있다.
* 카운트 값이 0이면 진입이 가능하고, 이상이면 진입이 불가능하다.
* 공유된 자원의 데이터를 여러 프로세스가 접근하는 것을 막아준다.

## 뮤텍스와 세마포어

* 세마포어는 뮤텍스가 될 수 있지만, 뮤텍스는 세마포어가 될 수 없다.
* 세마포어는 소유할 수 없는 반면, 뮤텍스는 소유가 가능하며 소유주가 이에 대한 책임을 지닌다.
* 뮤텍스의 경우 뮤텍스를 소유하고 있는 스레드가 이 뮤텍스를 해제할 수 있다. 하미잠 세마포어의 경우 세마포어를 소유하고 있지 않은 스레드도 세마포어를 해제할 수 있다.
* 세마포어는 시스템 범위에 걸쳐있고 파일 시스템상의 파일 형태로 존재한다. 반면 뮤텍스는 프로세스 범위를 가지며 프로세스가 종료될 때 자동으로 clean up 된다.
* 뮤텍스는 동기화 대상이 오직 하나뿐일 때, 세마포어는 동기화 대상이 하나 이상일 때 사용한다.

## 옵저버 패턴

## 템플릿 패턴

## 팩토리 패턴

## 해쉬맵, 해쉬

## TCP

## UDP

## 데드락

## Race Condition

## Http Method

## CORS

## Spring MVC 동작 과정

## 3 Way HandShake

## 4 Way HandShake

## Java Exception

## OAuth

## Spring에 사용된 디자인 패턴

## Replication(리플리케이션)

* 두 개 이상의 DMBS 시스템을 Master/Slave로 나눠서 동일한 데이터를 저장하는 방식
* Master에는 데이터의 수정 사항을 반영만 하고 Replication을 하여 Slave에 실제 데이터를 복사한다.
* INSERT/UPDATE/DELETE는 Master가 담당하고 SELECT는 Salve가 담당해서 성능 향상 효과를 얻을 수 있다.
* 로그 기반 복제
  * Statement Based : SQL 문장을 복사하여 진행
  * Row Based : SQL에 따라 변경된 Row 라인만 기록하는 방식
  * Mixed : 기본적으로 Statement Based로 진행하면서 필요에 따라 Row Based를 사용한다.

## Sharding(샤딩)

* 수평 파티셔닝과 동일하다.
* 대용량의 데이터를 처리하기 위해 테이블을 수평 분할하여 데이터를 분산 저장하고 처리하는 것
* 같은 타입의 데이터를 다수의 데이터베이스에 쪼개서 저장하는 것
* 샤딩 알고리즘이 매우 쉽게 일반화가 가능하기에 애플리케이션 레벨이나 데이터베이스 레벨에서 구현이 가능함

## Partitioning(파티셔닝)

* 큰 테이블이나 인덱스를 관리하기 쉬운 단위로 분리하는 방법을 의미한다.
* 물리적인 파티셔닝으로 인해 전체 데이터의 훼손 가능성이 줄어들고 데이터 가용성이 향상된다.
* 큰 테이블들을 제거하여 관리를 쉽게 해준다.
* 특정 DML과 쿼리의 성능을 향상시킨다. 주로 대용량 Data Write 환경에서 효율적이다.
* 많은 insert가 있는 OLTP 시스템에서 insert 작업들을 분리된 파티션들로 분산시켜 경합을 줄인다.
* 테이블간의 Join에 대한 비용이 증가한다.
* 테이블과 인덱스를 별로 파티션 할 수는 없다. 테이블과 인덱스를 같이 파티셔닝하여야 한다.

## 로드밸런싱

## 클러스터링

## Join 원리

* 평소 데이터는 하드디스크의 데이터 파일에 저장해 두었다가 필요한 시점에 메모리로 복사한다.

* 컬럼 100개를 가진 테이블이 하드디스크에 저장되어 있을 때 사용자가 그 중 1개의 칼럼에 SELECT를 수행할 경우 해당 컬럼 1개만 메모리로 복사하는 것이 아니라 일단 100개의 칼럼 모두를 메모리로 복사해 온다.

* 그래서 불필요한 I/O도 많고 메모리 사용량도 많이 생기기 때문에 정규화를 철저히 해서 부하를 최대한 줄여야 한다.

* Join 수행 작업 순서

  1. 사원 테이블과 부서 테이블을 메모리(데이터베이스 버퍼 캐시)로 복사해온다.

  2. 그후에 사원테이블에서 사원이름을 꺼내서 임시 작업공간으로 가져 간다.(인덱스 상황이나 다른 요소에 따라 작업순서가 변경될 수도 있다.)

  3. 그 후에 부서 테이블에서 해당부서명을 찾으러 가는데 그때 위 SQL의 3행에 있는 조건을 보고 해당 조건에 맞는 데이터를 찾아서 부서명을 가져온다.

  4. 한 행의 작업이 끝나면 다시 처음 테이블로 돌아가서 두 번째 행의 이름을 다시 PGA로 가져온다.

  5. 다시 부서 테이블에 가서 사원 테이블에서 가져온 두 번째 행의 부서번호와 동일한 부서번호를 가진 부서명을 꺼내온다.

* 위 과정을 사원 테이블의 데이터가 끝이 날 때 까지 작업이 반복된다.

## Heap

## Object Oriented Programming (객체 지향 프로그래밍)

* 프로그램을 수많은 객체라는 기본 단위로 나누고 이 객체들의 상호작용으로 프로그램을 서술하는 방식
* 객체를 데이터 묶음 뿐만 아니라 하나의 역할을 수행하는 메소드와 데이터의 묶음
* 큰 문제를 작게 쪼개는 것이 아니라, 먼저 작은 문제들을 해결할 수 있는 객체들을 만든 뒤, 이 객체들을 조합해서 큰 문제를 해결하는 상향식(Bottom up) 해결법 도입
* 캡슐화(Encapsulation)
  * 프로그램의 세부 구현을 외부로 드러나지 않도록 특정 모듈(클래스) 내부로 감추는 것이다.
  * 접근 제어 지시자를 통해 외부에서 접근을 제어 한다.
* 상속(Inheritance)
  * 자식 클래스가 부모 클래스의 특성과 기능을 그대로 물려받는 것을 말한다.
  * 오버라이딩을 통해 자식 클래스에서 상속받은 기능만을 재 정의해 사용이 가능하다.
* 다형성(Polymorphism)
  * 하나의 변수, 함수등이 상황에 따라 다른 의미로 해석될 수 있다
  * 오버로딩

## Array

* 특정 자료형들이 메모리 공간상에서 연속적으로 이루어져 있는 자료구조
* 데이터를 메모리상에 연속적으로 나열해두었다는 특성 때문에 데이터에 대한 접근이 엄청나게 빠르다.
* index 값을 통해 바로 원하는 공간에 가서 자료를 확인할 수 있기 때문에, 딱 한번의 접근만 필요하므로 O(1)의 시간 복잡도를 가진다.
* immutable이다.

## Linked List

* 여러개의 노드들이 연결된 형태의 자료구조
* 메모리 공간상에서 각 노드들이 연속적으로 이루어져 있지 않고 흩어져 있으며, 각각의 노드가 자신의 다음 노드의 위치를 알고 잇는 형태로 구현된다.
* 각 노들이 메모리 공간상의 어디에 위치하는지 각각의 노드들만 알고 있고, 사용자는 제일 첫 노드의 위치만 알고 있게 된다.
* O(N)의 시간 복잡도를 가진다.
* 노드를 추가하고 제거하는 과정을 통해 최대 노드의 수를 언제든지 변경할 수 있기 때문에 공간을 유동적으로 사용할 수 있다.
* 노드의 삽입,삭제도 배열에 비해 간단하다.

## Linked List(연결 리스트) VS Array(배열)

* 배열은 데이터의 접근은 빠르지만, 메모리 공간활용에 제약이 있으며, 데이터의 추가와 삭제가 비효율적이다.
* 연결 리스트는 데이터의 접근이 다소 느리지만, 메모리 공간 활용 및 데이터의 추가와 삭제가 효율적이다.

## Hystrix 생명 주기

## Java Default

## 함수형 프로그래밍

* 순수 함수를 조합하고 공유 상태, 변경 가능한 데이터 및 부작용을 피하여 소프트웨어를 만드는 프로세스
* 명령형이 아닌 선언형

## Java Enum

* 열거 타입, 변수를 선언할 때 변수 타입으로 사용할 수 있다.
* IDE의 지원을 받을 수 있다.(자동 완성, 오타 검증, 텍스트 리팩토링)
* 허용 가능한 값들을 제한할 수 있다.
* 리팩토링시 변경 범위가 최소화된다. 내용의 추가가 필요하더라도, Enum 코드외에 수정할 필요가 없다.
* 완전한 기능을 갖춘 클래스이다.