# 카카오IX 면접 준비

## 인터페이스

* 클래스들이 구현해야 하는 동작을 지정하는데 사용되는 추상형
* 규약, 규제
* 추상 클래스의 극단적인 경우
* 인터페이스도 상속이 가능하다.
* 클래스와 달리 다중 상속이 가능하다.
* 자바 8에서 인터페이스가 가질 수 있는것
  * 상수 필드(public static final) : 기존, 생략 가능
  * 추상 메소드(public abstract)  : 기존 ,생략 가능
  * 디폴트 메소드(public default) : 추가
    * 이전에 개발한 구현 클래스를 그대로 사용하지 않고 변경하지 않으면서, 새롭게 개발하는 클래스는 디폴트 메소드를 활용해 새로운 기능을 만들 수 있다.

## 다형성

* 다형성 조건
  * 공통의 부모
  * 공통의 메소드 재정의
  * 부모 타임의 변수로 호출

## 제네릭

* 다양한 타입의 객체들을 다루는 메소드나 컬렉션 클래스에 컴파일 시의 타입 체크를 해주는 기능이다.
* 클래스 내부에서 사용할 데이터 타입을 나중에 인스턴스를 생성할 때 확정하는 것을 제네릭이라 한다.
* 타입 안정성을 제공한다.
* 타입체크와 형변환을 생략할 수 있으므로 코드가 간결해진다.

## JVM

* 자바 애플리케이션을 클래스 로더를 통해 읽어 들려 자바 API와 함께 실행하는 것이다.
* 자바 바이트 코드를 실행할 수 있는 주체이다.
* 인터프리터나 JIT 컴파일 방식으로 다른 컴퓨터 위에서 자바 바이트 코드를 실행할 수 있도록 구현한다.
* 자바 바이트코드는 플랫폼에 독립적이다.
* 모든 JVM은 JVM 규격에 정의된 대로 자바 바이트 코드를 실행한다.
* 스택 기반이다.
* 대다수의 명령어가 스택 선두에서 피연산자를 택하고 결과는 다시 스택에 넣는다.
* 포인터를 지원하지만, C 처럼 주소 값을 임의로 조작이 가능한 포인터 연산은 불가능하다.
* GC를 사용한다.
* 메모리 관리가 가능하다.
* 

## GC

## Spring

* 스스로 발전하는 프레임워크
* 스프링 개발 철학 중 하나는 "항상 프레임워크 기반의 접근 방법을 사용하라"
* 스프링 기능의 대부분은 핵심 기능을 확장해서 발전시킨 결과물이다.
* 단순함과 유연성을 중요 가치로 생각한다.
* 정의 : 자바 엔터프라이즈 개발을 편하게 해주는 오픈소스 경량급 애플리케이션 프레임워크

## Spring Bean Life Cycle

## Spring Container

## Spring Data JPA

## Servlet

* 자바를 사용하여 웹 페이지를 동적으로 생성하는 서버측 프로그램
* 웹 서버의 성능을 향상하기 위해 사용되는 자바 클래스의 일종이다.
* JSP와 비슷한 점이 있지만, JSP는 html 문서 안에 자바 코드를 포함하고 있지만, 서블릿은 자바 코드안에 HTML을 포함하고 있다.
* 외부 요청마다 스레드로 응답하므로 가볍다.

## Dispatcher Servlet

* 해당 애플리케이션으로 들어오는 요청을 모두 핸들링해준다.
* Dispatcher Servlet을 이용한다는 것은 스프링에서 제공하는 @MVC를 이용하겠단 뜻
* HTTP 프로토콜을 통해 들어오는 모든 요청을 프레젠테이션 계층의 제일 앞에 둬서 중앙 집중식으로 처리해주는 프론트 컨트롤러(Front Controller)
* 공통 처리 작업을 Dispatcher Servlet이 처리한 수, 적절한 세부 컨트롤러로 작업을 위임해 준다.
* web.xml의 역할을 상당히 축소시켜주었다.

## Java Bean

* 원래는 비주얼 툴에서 조작 가능한 컴포넌트를 말한다.
* 간단히 빈이라고 부르기도 한다.
* 현재는 다음 두 가지 관계를 따라 만들어진 오브젝트를 가리킨다.
  * 디폴트 생성자 : 자바빈은 파라미터가 없는 디폴트 생성자를 갖고 있어야 한다. 툴이나 프레임워크에서 리플렉션을 이용해 오브젝트를 생성하기 때문에 필요하다.
  * 프로퍼티 : 자바빈이 노출하는 이름을 가진 속성을 프로퍼티라고 한다. 프로퍼티는 set으로 시작하는 수정자 메소드(setter)와 get으로 시작하는 접근자 메소드(getter)를 이용해 수정 또는 조회할 수 있다.

## DAO(Data Access Object)

* DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트를 말한다.

## ORM

* 객체와 관계형 DB를 Mapping해 준다.
* 객체와 테이블을 Mapping하기 때문에 SQL 쿼리를 직접 날리는 것이 아니라 마치 자바에서 라이브버리 사용하듯이 사용하면 된다.
* 객체와 관계형 데이터베이스와의 설정을 자동으로 해준다.
* 실제 데이터와 객체와의 개념적 일치하지 않는 부분을 자동으로 매핑해준다.
* 관계형 데이터베이스의 데이터를 객체형 데이터처럼 사용할 수 있다.
* Mybatis, iBatis, JPA, Hibernate
* 장점
  * 객체 지향적인 코드로 인해 더 직관적이고 비즈니스 로직에 집중할 수 있게 도와준다.
  * 선언문, 할당, 종료 같은 부수적인 코드가 줄어든다.
  * 재사용 및 유지 보수의 편리성이 증가한다.
  * DBMS에 대핸 종속성이 줄어든다.
  * SQL의 절차적이고 순차적인 접근이 아닌 객체 지향적인 접근으로 인해 생산성이 증가한다.
* 단점
  * 모든 기능을 ORM으로만 작성하기에는 쿼리가 복잡해지면 쓰기 어렵다.
  * 많은 수의 레코드를 잦은 빈도로 벌크 수행
  * 완벽한 ORM으로만 서비스를 구현하기가 어렵다.
  * 프로시저가 많은 시스템에선 ORM의 객체 지향적인 장점을 활용하기 어렵다.

## 주소창에 주소를 입력 했을 경우 동작

## 자바8

* 새로운 기능
  1. 람다 표현식
     * 동작과 데이터를 모두 동적으로 설정하는 것이 가능하다.
     * 메소드 참조가 가능하다.
  2. 스트림 API
     * 배열이나 리스트, 맵으로 대표되는 컬랙션을 스트림으로 다룰 수 있게 되었다.
  3. 인터페이스 개선
     * 인터페이스에서 static 메소드를 정의하는 것이 가능하다.
     * default 지시자를 이용해 기본 메소드의 정의가 가능하게 되어 인터페이스를 구현하는 기존 코드의 변경없이 새 메소드의 추가가 가능하다.
  4. Optional
     * 값을 Optional<T>로 캡슐화하여 NPE를 막는다.

## AOP

## DI

## IOC

## DB Index

* RDBMS에서 검색 속도를 높이기 위해 사용하는 기술
* 색인
* 해당 테이블의 컬럼을 색인화(따로 파일로 저장)하여 검색시, 테이블의 레코드를 full scan 하는것이 아니라 색인화 되어있는 index 파일을 검색하여 검색 속도를 빠르게 한다.
* B+ 트리로 저장된다.
* index로 설정한 컬럼 값이 변경되거나 추가되면, index 역시 변경된다. 따라서 적절하게 index를 설정해야 한다.
* 데이터의 삭제, 삽입이 빈번한 경우 index의 성능이 떨어진다. 매번 B+트리를 수정해야 하기 때문이다.
* index가 데이터베이스 공간을 차지하기 때문에 추가적인 공간이 필요하다.(10% 만큼의 추가적인 공간이 필요하다.)
* index를 생성하는데 시간이 많이 소요될 수 있다.
* index의 목적 : RDBMS의 검색 속도를 높이는데 있다.
* SELECT 쿼리의 WHERE 절이나 JOIN 예약어를 사용했을 때만 인덱스가 사용되며 SELECT 쿼리의 검색 속도를 빠르게 하는게 목적이다.
* 따라서 WHERE 절에서 사용되는 컬럼을 index로 만드는 것이 좋다.
* 데이터의 중복도가 높은 열은 index로 만들어도 효용가치가 없다.
* 외래키가 사용되는 열에는 인덱스를 생성해 주는 것이 좋다.
* INSERT/UPDATE/DELETE가 얼마나 자주 일어나는지를 고려해서 index를 설정해야 한다.
* 사용하지 않는 index는 제거하는 것이 좋다.

## MySql 엔진

* InnoDB : 기본값 스토리지 엔진
  * 트랜잭션 세잎, 커밋과 롤백, 데이터 복구 기능을 제공한다
  * row-level locking을 제공한다.
  * 데이터를 clusterd index에 저장하여 PK 기반의 query의 I/O 비용을 줄인다.
  * FK 제약을 제공하여 데이터 무결성을 보장한다.
* MyISAM 
  * 트랜잭션을 지원하지 않고, 테이블 단위의 locking을 제공한다.
  * 멀티 쓰레드 환경에서 성능이 저하 될 수 잇다.
  * 특정 세션이 테이블을 변경하는 동안 테이블 단위로 락이 잡힌다.
* Archive
  * 로그 수집에 적합한 엔진
  * 데이터가 메모리 상에서 압축되고 압축된 상태로 디스크에 저장된다.
  * row-level locking이 가능하다.
  * 한번 INSERT 된 데이터는 UPDATE/DELETE를 사용할 수 없다.
  * 인덱스를 지원하지 않는다.
  * 거의 가오하지 않을 원시 로그 데이터를 관리하는데 효율적이고, 테이블 파티셔닝도 지원한다.
  * 트랜잭션은 지원하지 않는다.

## OSI 7계층

## Object Pool

* 객체를 필요로 할 때 풀에 요청을 하고, 반환하는 일련의 작업을 수행하는 패턴
* 많은 수의 인스턴스를 생성할 때, 혹은 무거운 오브젝트를 매번 인스턴스화 할 때 성능 향상을 가져오기도 한다.
* 데이터 베이스에 접속하는 객체를 만들 때 매번 새로 생성하는 것 보단, 미리 생성된 풀에서 객체를 반환받아오는 것이 더 효율적이다.
* 오브젝트 불은 객체를 관리하는 그룹과 같다.
* pool이라는 곳에 객체를 생성하고 반환하는 행위 등이 이루어진다.

## Tomcat

* 아파치 소프트웨어 재단에서 개발한 서블릿 컨테이너 / 웹 컨테이너만 있는 WAS
* 웹 서버와 연동하여 실행할 수 있는 자바 환경을 제공하여 JSP와 자바 서블릿이 실행할 수 있는 환경을 제공한다.
* HTTP 서버도 자체 내장하기도 한다.
* 서블릿이나 JSP를 실행하기 위한 서블릿 컨테이너를 제공하며, 상용 WAS에서도 서블릿 컨테이너로 사용하는 경우가 많다.
* 아파치 웹 서버와 연동 모듈을 사용하여 안정적인 시스템을 구축한다.

## WAS(Web Application Server)

* 인터넷 상에서 HTTP를 통해 사용자 컴퓨터나 장치에 애플리케이션을 수행해 주는 미들웨어
* WAS는 동적 서버 컨텐츠를 수행하는 것으로 일반적인 웹 서버와 구별이 되며, 주로 DB 서버와 같이 수행이 된다.
* 대부분 자바 기반이다.
* 일반적으로 Web Server의 기능을 내제하고 있어 Web Server가 없어도 서비스가 가능하다.
* 프로그램 실행 환경과 데이터베이스 접속 기능을 제공한다.
* 여러 개의 트랜잭션을 관리한다.
* 업무를 처리하는 비즈니스 로직을 수행한다.

## WAS 생명주기

1. Web Server로 부터 요청이 들어오면 제일 먼저 컨테이너가 이를 알맞게 처리한다.
2. 컨테이너는 web.xml를 참조하여 해당 서블릿에 대한 스레드를 생성하고 HttpServeltRequest 및 HttpServletResponse 객체를 생성하여 전달한다.
3. 다음으로 컨테이너는 서블릿을 호출한다.(service())
4. 호출된 서블릿의 작업을 담당하게 된 스레드(미리 생성된 스레드)는 요청에 따라 doPost(), 또는 doGet()을 호출한다.
5. 호출된 doPost(), doGet() 메소드는 생성된 동적 페이지를 Response 객체에 실어서 컨테이너에 전달한다.
6. 컨테이너는 전달받은 Response 객체를 HttpResponse 형태로 전환하여 웹 서버에 전달하고 생성되었던 스레드를 종료하고 HttpServletRequest 및 HttpServletResponse 객체를 소멸시킨다.

## 접근 제어 지시자

* 나머지 생략
* default : 클래스 내부와 동일 패키지에서만 접근을 허용한다.

## 페이징

## 스케쥴링

## Mutex

## Semaphore

## 레플리케이션

## 옵저버 패턴

## 템플릿 패턴

## 팩토리 패턴

## 해쉬맵, 해쉬

## TCP

## UDP

## 데드락

## Race Condition

## Http Method

## CORS

## Spring MVC 동작 과정

## 3 Way HandShake

## 4 Way HandShake

## Java Exception

## OAuth

## Spring에 사용된 디자인 패턴

## 샤딩

## 파티셔닝

## 로드밸런싱

## 클러스터링

## Heap

## OOP

## Linked List VS Array

## Hystrix 생명 주기

## Java Default

